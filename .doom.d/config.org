:DOC-CONFIG:
# Tangle by default to config.el, which is the most common case
#+property: header-args:emacs-lisp :tangle config.el
#+property: header-args :mkdirp yes :comments no
#+startup: fold
:END:

#+title: Doom Emacs Configuration
#+author: masukomi
#+email: masukomi@masukomi.org
#+STARTUP: showall

* What is this?
This is my "Literate" config file for Doom Emacs. More accurately, it's the /source/ of my config file for Doom Emacs. When I need to add or change something, I do so here, and then run ~C-c C-v t~ to regenerate my ~config.el~ only the "tangled" code examples are copied over, and the descriptions and notes outside of the examples remain behind.

This technique isn't limited to Emacs configs. If you'd like to learn how to do this for /any/ config on your computer. I'd recommend a great little book called [[https://leanpub.com/lit-config/read][Literate Configuration by Diego Zamboni]]. You can read it free online, or pay what you want / can to tell them thanks and get a PDF / Epub version.

** Ok, but why?
Three reasons:

1. I have ADHD and am guaranteed to forget that 99% of this exists, nevermind what it does. Now I've got a good reference.
2. I've found /so many/ useful solutions to problems I've had in other people's configs. Sometimes though, it's not very clear what's happening and if it is really what I want. I'm hoping that some future person I going to wonder how to do some of the things I've done, find this in a search result, and not only /find/ an answer to their problem, but /understand/ that answer too.
3. This is just so much more /easier/ to understand when I need to tweak something.

* 🤞Trying to prevent myself from editing the wrong file
Yes, ~config.el~ is what Doom reads, but this is what creates that.

#+begin_src elisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
;;
;; DO NOT READ THIS. DO NOT EDIT THIS.
;; READ config.org instead!
;;
;; This is a file generated from a literate programing source file located at
;; https://github.com/masukomi/masuconfigs/blob/master/.doom.d/config.org
;;
;; config.org HAS ALL OF THE JUICY DETAILS
;; Future me: You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)
;;
#+end_src

#+RESULTS:

* General Config

Tell it where to find custom elisp files.
At the time of writing this consists of

- ~eruby-mode.el~
- ~flycheck-standardrb.el~
- ~ruby-align.el~
- ~screenshot.el~
- ~sh-send-line-or-region.el~
- ~titlecase.el~
  This one relies on the [[https://github.com/ap/titlecase][titlecase]] perl script being in your ~exec-path~

#+begin_src elisp :tangle config.el
;;---------------------------------
;; General Config
(add-to-list 'load-path "~/.doom.d/custom")
(load "eruby-mode")

#+end_src

When an external force changes a file I have open in emacs I'd like those changes to be loaded instead of ignored, and accidentally overwritten. Note that [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Revert.html#Auto-Revert][Auto Revert]] will /not/ revert a buffer if it has unsaved changes, or if its file on disk is deleted or renamed.

When a buffer is auto-reverted, a message is generated. This can be suppressed by setting ~auto-revert-verbose~ to ~nil~.

#+begin_src elisp :tangle config.el
; automatically sync buffer with changes in the filesystem
(global-auto-revert-mode t)
#+end_src

By default emacs asks you if you /really/ want to quit, even if there's nothing unsaved. It does this /multiple/ times. Even worse, it then prints out some really uncool "jokes" that probably sounded funny to a young white tech geek decades ago in a society that was fine with being disrespectful to anyone who wasn't a privileged white guy.

Fuck all of that.

#+begin_src elisp :tangle config.el
(setq confirm-kill-emacs nil) ; 'y-or-n-p
#+end_src

* Tell them it was me.
I don't actually know if I use anything which uses this, but it seems reasonable to fill out.

#+begin_src elisp :tangle config.el
;; These are used for a number of things, particularly for GPG configuration,
;; some email clients, file templates and snippets.
(setq user-full-name "Kay Rhodes"
      user-mail-address "masukomi@masukomi.org"
      org-export-default-language "en-US")
#+end_src

* Teaching Emacs how to be a good citizen
** Stop crapping in my directories!
I loathe the backup files emacs litters your working directories with =foo.txt~= autosave files. They're unsightly and far too easy to accidentally commit to your codebase.

Move them to =~/.emacs_backups/= & =~/.emacs_autosave/=

#+begin_src elisp :tangle config.el
; eff you emacs. Stop litering my directories with backup files.
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

If you get really annoyed you can disable auto-save and auto-backup entirely, but that seems like removing an important safeguard to me.

#+begin_src elisp
(setq auto-save-default nil)
(setq make-backup-files nil)
#+end_src

** Stop being weird about cut
Everyone else uses ~⌘+x~ or ~^x~. I get that Emacs' way predated fancy GUI OSs, but it sucks to be literally the only app on my computer that refuses to copy & paste with normal shortcuts.

#+begin_src elisp :tangle config.el
(bind-key* (kbd "C-x") 'kill-region)
#+end_src

Because someone's going to read the above and think I'm an idiot for not turning on CUA:

When Common User Access (CUA) mode is enabled, the keys C-x, C-c, C-v, and C-z
invoke commands that cut (kill), copy, paste (yank), and undo respectively. Which is to say, it makes it work like every other app on your computer.

Unfortunately, this completely borks new list item functionality in org-mode
and it overrides the C-V functionality in evil (visual selection block mode). So, we can't actually run ~(cua-mode t)~
** Why can't you window?
For some reason GUI emacs on macOS seems incapable of remembering its window size and it defaults to something ridiculously small.

Note that the sizes here are in characters.

#+begin_src elisp :tangle config.el
; kinda-sorta forcing initial window size because it seems incapable
; of remembering
(setq default-frame-alist '((left . 106) (width . 106) (fullscreen . fullheight)))
#+end_src
** Make it easy to reload .dir-locals.el
Directory specific variables are stored in ~.dir-locals.el~ files. These are especially important for setting project-specific variables and things like that. Alas, it doesn't seem that Emacs has a way to easily reload these if you've modified them after loading.

Here are two helper methods to do that.

#+begin_src elisp :tangle config.el
; .dir-locals.el helper methods
(defun my-reload-dir-locals-for-current-buffer ()
  "reload dir locals for the current buffer"
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
  "For every buffer with the same `default-directory` as the
current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir)
          (my-reload-dir-locals-for-current-buffer))))))
#+end_src

* Configuring Doom Itself
First: Make that splash-screen cuter. I don't really like the "Doom" video game logo, but [[https://github.com/jaidetree][jaidtree]] contributed a really cute Doom monster graphic in [[https://github.com/doomemacs/doomemacs/issues/3382][this GitHub Issue]].

I've stored a few sizes of it in =~/.doom.d/images/=

Doom calls this the ~fancy-splash-image~ and all you need to do is point that variable at an image you like in a size that seems good to you.

#+begin_src elisp :tangle config.el
(setq fancy-splash-image "~/.doom.d/images/doom_icon_256x256.png")
#+end_src

* macOS compensation
** PATH variable is non-standard
#+begin_quote
On OS X (and perhaps elsewhere) the $PATH environment variable and
`exec-path' used by a windowed Emacs instance will usually be the
system-wide default path, rather than that seen in a terminal
window.

This library allows the user to set Emacs' `exec-path' and $PATH
from the shell path, so that `shell-command', `compile' and the
like work as expected. - [[https://melpa.org/#/exec-path-from-shell][exec-path-from-shell docs]]
#+end_quote

It does some extra gyrations if you're using a non-POSIX compliant shell like [[https://fishshell.com/][fish]] or [[https://www.tcsh.org/][tcsh]], but noting significant.

#+begin_src elisp :tangle config.el
; https://melpa.org/#/exec-path-from-shell
(exec-path-from-shell-initialize)
#+end_src

** allow me to use the option key to type special characters
For example: if you want to type the degrees symbol (°) on a mac you can type shift+option+8, or an accent grave á with option-e plus the character you want to accent, but it doesn't work in Emacs. It'd probably interfere with a lot of stuff.

In practice, I mostly just use ~insert-char~ to insert special characters, but sometimes it's nice to be able to use the built-in stuff, especially when documenting things with foreign language characters. After enabling it, we'll make it toggleable so that we can still access the normal emacs functions it potentially intersects with.

This ~mac-opt-keymap~ stuff was [[https://www.reddit.com/r/emacs/comments/mpbgx7/comment/gu9opv1/][found here on reddit.]]


#+BEGIN_SRC elisp :tangle config.el
; a macOS specific tweak to allow you to use the option key to
; type special characters like
; - an accent grave á <option-e a>
; - a degree sign ° <option-shift-8>
;
; toggle it with C-c m o
; found here: https://www.reddit.com/r/emacs/comments/mpbgx7/comment/gu9opv1/
(setq mac-opt-keymap (make-sparse-keymap))

;; equivalent to C-M-x with mac-opt-chars-mode on
(define-key mac-opt-keymap (kbd "C-≈") 'execute-extended-command)
#+END_SRC

To toggle this with ~C-c m o~ we need a helper function.

#+BEGIN_SRC elisp :tangle config.el
(defun mac-toggle-ns-alt-modifier ()
  (if (not mac-opt-chars-mode)
      (setq ns-alternate-modifier 'meta)
    (setq ns-alternate-modifier nil)))

(define-minor-mode mac-opt-chars-mode
  "Type characters with option as in other Mac applications."
  :global t
  :lighter " mac-opt-chars"
  :keymap mac-opt-keymap
  (mac-toggle-ns-alt-modifier))
                                        ; toggle it on and off with C-c m o
(define-key mac-opt-keymap (kbd "C-c m o") 'mac-opt-chars-mode)
(define-key global-map (kbd "C-c m o") 'mac-opt-chars-mode)
#+END_SRC




* Projectile
** I need to edit .dotfiles
[[https://projectile.mx/][Projectile]] is a project navgiation and management library. It's pretty cool. However, it tries to be a little too smart about things like hidden files. As such it'll never list a project's dotfiles like ~.gitignore~ or ~.env~. We need to tell it to use [[https://docs.projectile.mx/projectile/configuration.html#:%7E:text=Project%20indexing%20method%20Projectile%20has%20three%20modes%20of,obtain%20the%20list%20of%20files%20in%20a%20project]["native" indexing mode]].

#+begin_src elisp :tangle config.el
;; enable native indexing in Projectile so that we can easily
;; edit a project's dot files.
(setq projectile-indexing-method 'native)
#+end_src

** Not every repo I open is something I'm working on.
Projectile also, /really/ wants to be helpful. If you open a file that happens to be in a git repo it'll add that repo to your projects list. I look at a /lot/ of open source repos that I have no intention of working in, so this becomes a problem quickly. This will disable that behavior, and require you to add projects manually (~Space-p-a~)

#+begin_src elisp :tangle config.el
(setq projectile-track-known-projects-automatically nil)
#+end_src

** I want to create new files, not just edit existing ones.

convince projectile to create new files
not just find existing ones. All credit to [[https://www.reddit.com/user/hatschipuh/][/u/hatchipuh]]'s helpful [[https://www.reddit.com/r/emacs/comments/3m8i5r/helmprojectile_quickly_findcreate_new_file_in/][answer on reddit.]]

#+begin_src elisp :tangle config.el
(with-eval-after-load 'helm-projectile
  (defvar helm-source-file-not-found
    (helm-build-dummy-source
        "Create file"
      :action (lambda (cand) (find-file cand))))


  (add-to-list 'helm-projectile-sources-list helm-source-file-not-found t)
  (setq +workspaces-on-switch-project-behavior t)
  )
#+end_src
** Git integration
Projectile integrates with git to figure out what files are in your project.

The cache is always wrong after switching branches. If we use [[https://magit.vc/][magit]] (loaded via ~init.el~)to switch branches in our project, then we can auto-invalidate it.

#+begin_src elisp :tangle config.el
(defun run-projectile-invalidate-cache (&rest _args)
  ;; We ignore the args to `magit-checkout'.
  (projectile-invalidate-cache nil))
(advice-add 'magit-checkout
            :after #'run-projectile-invalidate-cache)
(advice-add 'magit-branch-and-checkout ; This is `b c'.
            :after #'run-projectile-invalidate-cache)
#+end_src

* Autocompletion
Autocomplete and I are having a disagreement.

I really want it to stop invoking autocomplete prompts with just the enter key. This screws me constantly when I'm typing and hit return for the end of the line but the prompt appeared while my finger was on its way down.

I /thought/ this was the solution, but it wasn't.

#+begin_src elisp
;; don't accept autocomplete with _just_ return (⏎).
;; require ^-⏎
; PROBLEM:
; This doesn't work with whatever doom emacs is doing for
; autocomplete
(define-key ac-completing-map (kbd "RET") nil)
(define-key ac-completing-map [return] nil)
(define-key ac-completing-map [(control return)] 'ac-complete)
#+end_src

The following /should/ delay it, but doesn't seem to work 🤔. I don't know why, but it's all I've got so I'll keep hoping.

#+begin_src elisp :tangle config.el
; delay autocomplete a little bit longer
(setq auto-completion-delay 2)
#+end_src

* Indentation
I have strong opinions on [[https://weblog.masukomi.org/2010/07/26/why-you-should-never-indent-code-with-spaces/][Why you should never indent your code with spaces]], but the person responsible for Emacs' default indentation format was… I don't have words. Let's just say they set a default that "no-one" else would ever thing was reasonable, and is completely ignorant of the accessibility features built into the tab character.

By default, when you have a long section of indentation [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Indent-Tabs-Mode.html][Emacs will "helpfully" insert tabs in place of multiple spaces]]. So if you have something indented to the width of 10 spaces it'll use 2 tabs and 2 spaces. 🤦‍♀️

Turn that 💩 off, and while we're at it teach it how many characters worth of width a tab should be displayed as by default.

#+begin_src elisp :tangle config.el
; stop mixing tabs and spaces when indenting!
(setq-default indent-tabs-mode nil)
; i like tabs to be 4 characters wide.
; the beauty of the tab character is that
; it can show as 4 chars on mine, and 2 or 20 on yours.
(setq-default tab-width 4)
#+end_src


Unfortunately, different languages have different default indentation styles, and none of them give a 💩 about accessibility. Alas, you gotta code in whatever style the language uses or you'll piss off your coworkers. That's where [[https://github.com/jscheid/dtrt-indent][dtrt-indent]] comes in. It also helps when your coworkers have gone rogue and come up with their own indentation house-style.

#+begin_quote
[dtrt-indent is] An Emacs minor mode that guesses the indentation offset originally used for creating source code files and transparently adjusts the corresponding settings in Emacs, making it more convenient to edit foreign files.
#+end_quote


#+BEGIN_SRC elisp :tangle config.el
;; turn on dtrt-indent, which makes it use the right indentation.
(setq dtrt-indent-global-mode t)
#+END_SRC

Now, we can make those leading tabs and spaces visible. So like, when we're using python we can see the correct indentation. This one is thanks to [[http://xahlee.info/emacs/emacs/emacs_init_whitespace_mode.html][Xah Lee]].

#+BEGIN_SRC elisp
; make leading whitespace visible
(setq whitespace-style (quote (face indentation tabs tab-mark spaces trailing lines-tail)))
(setq whitespace-display-mappings
      '(
        (tab-mark 187 [9655 187] [92 187]) ; "right pointing doube angle quotation mark" 187 「»」, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」, 92 「\」
        )
      )
#+END_SRC

That's pretty much the setup I had in Vim for ages. Loved it, but there's also [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides.el]] which is what I've been using instead. It provides subtle - or not so subtle - lines connecting the top and bottom of an indented section. It's nice because sometimes I'll end up with a section that's only 1 space indented instead of 2 and the vertical bars being too close to each other makes it clear I've messed up. Check out the animated screenshot in the README.

The viable options here are: fill, column, character, or bitmap. I'm kinda intrigued by "bitmap". Someone must have done something cool with it.

#+BEGIN_SRC elisp :tangle config.el
; indentation guides
(setq highlight-indent-guides-method 'character)
#+END_SRC
* Alignment
[[https://github.com/emacsmirror/ialign][ialign]] is a visual alignment tool, that allows you to select some text, invoke it, enter a regexp, and see what the results will be interactively.

#+BEGIN_SRC elisp :tangle config.el
;; ialign (interatvie alignment)
(global-set-key (kbd "C-x l") #'ialign)
#+END_SRC

* Word Wrapping
Vim's word wrapping is an effing nightmare with how it screws with arrow key movement. I'm so happy to be free of that.

Doom has a minor mode called [[https://github.com/hlissner/doom-emacs/blob/3614109c7a0cdd5bc474f095beebe9c126ae8f01/modules/editor/word-wrap/README.org
][+word-wrap-mode]] built in "…which intelligently wraps long lines in the buffer without modifying the buffer content."

It's pretty cool, but for reasons I can't recall, /I no longer have this enabled/. But I kept the details in my old config. 🤔 Maybe it's just trauma from Vim's stupid wrapping. Anyway…

You can enable it in a specific language with this:

#+begin_src elisp
; enable +word-wrap-mode in C, C++, ObjC, & Java
(add-hook 'c-mode-common-hook #'+word-wrap-mode)
#+end_src

Or disable it in a specific /mode/ with this:

#+begin_src elisp
(add-to-list '+word-wrap-disabled-modes 'emacs-lisp-mode)
#+end_src


Or you can enable it globally with this:

#+begin_src elisp
(+global-word-wrap-mode +1)
#+end_src

* Smartparens
Doom includes [[https://smartparens.readthedocs.io/en/latest/pair-management.html#el.function.sp-with-modes][Smartparens]] which is generally cool but its autocompletion of single and double quotes is absolutely incompatible with my 🧠.

#+begin_src elisp :tangle config.el
; don't auto-pair single quotes anywhere
(sp-pair "'" nil :actions nil)
; don't auto-pair double quotes anywhere
(sp-pair "\"" "\"" :actions nil)
; don't auto-pair escaped double quotes either
(sp-pair "\\\"" "\\\"" :actions nil)
#+end_src

Here's how you'd disable those in just a specific mode.

#+begin_src elisp
(sp-with-modes 'ruby-mode
  (sp-local-pair "'" nil :actions nil)
  (sp-local-pair "\"" nil :actions nil))
#+end_src

* Neotree
[[https://github.com/jaypei/emacs-neotree][Neotree]] An Emacs clone of Vim's NerdTree. I keep forgetting i have it installed. If I ever feel like invoking it, I think it'd be good to have it represent the current state of my working directory, rather than what it happened to look like when I launched it.

#+begin_src elisp :tangle config.el
; neotree should autorefresh to maintain a current
; representation of your directories.
(setq neo-autorefresh t)
#+end_src

* Yasnippet
[[https://github.com/joaotavora/yasnippet][Yasnippet]] is a pretty awesome "template system" for Emacs. Somewhere along the way I had a problem with my custom snippets not being loaded at startup.

If custom snippets aren't loading first run this and restart doom.

#+begin_src bash
cd ~/.doom.d/snippets
find . -name ".yas-compiled-snippets.el" -exec rm -f '{}' \;
#+end_src

If THAT doesn't work, you've got other problems but maybe disabling this will
work as a stopgap:

#+begin_src elisp
(add-hook 'emacs-startup-hook (lambda () (yas-load-directory "~/doom.d/snippets")))
#+end_src

* Graphical & GUI things
** I want to be pretty.
*** Fonts matter
[[https://www.jetbrains.com/lp/mono/][JetBrains Mono]] is a lovely monospaced font that really works for me.

#+begin_src elisp :tangle config.el
(setq doom-font (font-spec :family "JetBrains Mono Medium" :size 20)
      doom-variable-pitch-font (font-spec :family "Monaco")
      doom-big-font (font-spec :family "JetBrains Mono Medium"))
#+end_src

*** Themes matter too
I'm really enjoying the [[https://github.com/morhetz/gruvbox][gruvbox]] theme. Before that I was using the [[https://github.com/emacsfodder/emacs-theme-darktooth][darktooth theme]].

There's a [[https://github.com/doomemacs/themes][theme megapack]] which links to many good theme repos and has a [[https://github.com/doomemacs/themes/tree/screenshots][screenshots page]] where you can preview everything in the megapack.

#+begin_src elisp :tangle config.el
(setq doom-theme 'doom-gruvbox)
#+end_src

*** And cursors
Doom Emacs sets "faces" differently than normal emacs. I don't really understand why, but there are two methods to use ~custom-set-faces!~ and ~set-face-attribute~

The best overview I've found is [[https://discourse.doomemacs.org/t/how-to-switch-customize-or-write-themes/37][this tutorial]] about customizing themes and faces in Doom.

Without the following I end up with a black cursor with almost black text inside, or vice-versa. It's hard to tell.

#+begin_src elisp :tangle config.el
(custom-set-faces!
  '(cursor :background "#AA00FF") ; doesn't seem to work
  '(cursor :foreground "#FFFFFF")
        )
#+end_src

Henrik's advice is to use ~custom-set-faces!~ in most situations, but when you are doing something like configuring a thing that isn't static to begin with (different heading colors of different headings in an org-mode file for example) you should use ~set-face-attribute~. He provides an example [[https://discourse.doomemacs.org/t/how-to-best-change-face-settings-custom-set-faces-or-set-face-attribute/2721][in this thread]].

*** Absolute & Relative Line Numbers

Line numbers are important. For us Vim expats, relative line numbers save a lot of counting, but we still need to know which line is the the one the error message complained about.
So, I have /both…/ most of the time.

#+begin_src elisp :tangle config.el
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; for both, you gotta get funky.
(setq display-line-numbers-type t)
;; commence funkyness…
(display-line-numbers-mode)
(nlinum-relative-on)
(nlinum-relative-setup-evil)               ;; setup for evil
(add-hook 'prog-mode-hook 'nlinum-relative-mode)
(setq nlinum-relative-redisplay-delay 0)   ;; delay
(setq nlinum-relative-current-symbol "->") ;; or "" for display current line number
(setq nlinum-relative-offset 0)            ;; 1 if you want 0, 2, 3...
#+end_src
*** Highlighting code in parens
Not the prettiest, but it's very useful when working in lisp and scheme. This will highlight the contents of a paretheses when you leave the cursor on the start or end one.

#+begin_src elisp :tangle config.el
; highlight the contents of the selected parentheses
(setq show-paren-delay 0)
(setq show-paren-style 'expression)
(set-face-attribute 'show-paren-match-expression nil
		    :background "peru"
		    :foreground "beige")
(show-paren-mode 1)
#+end_src
*** A rainbow of colors!
auto-highlights css colors like #ffffff with [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]]

I haven't figured out how to do this with with straight-use-package
or if one even should.

#+begin_src elisp :tangle config.el
; highlight CSS color codes in the color they represent
(use-package rainbow-mode
  :hook (prog-mode . rainbow-mode ))
#+end_src

*** Git change indicator

It's also nice to have a subtle hint that a line has been changed, or added, but not committed. Maybe you didn't mean to change that line. Well, no worries Dear, [[https://github.com/emacsorphanage/git-gutter#readme][git-gutter]] is here, and Doom Emacs is already set up to use it via the [[https://github.com/doomemacs/doomemacs/tree/develop/modules/ui/vc-gutter][vc-gutter]] in ~init.el~ Git Gutter puts thin colored vertical lines in Emacs' gutter that correspond to changed code if you tell it you want to be =+pretty= in the ~init.el~ by saying ~(vc-gutter +pretty)~

There's also [[https://github.com/emacsorphanage/git-gutter-fringe#readme][git-gutter-fringe]] which is a variant designed to work with ~linum-mode~ but it has its own downsides.

#+begin_src elisp :tangle config.el
; display the git gutter
(global-git-gutter-mode t)
#+end_src
*** Wait. What function is this?
[[https://github.com/alphapapa/topsy.el#readme][Topsy]] is a nifty little utility that keeps the name of the current function pinned to the top of the page when it scrolls off-screen. Every now and then I get a little confused and think it's the /actual/ line, but overall it's a nice little helper.

#+begin_src elisp :tangle config.el
; enable topsy mode when programming
(add-hook 'prog-mode-hook #'topsy-mode)
#+end_src

*** Disable the graphical toolbar
I'm never going to click on the save icon when I could just hit ⌘-s and Projectile is great for opening things.

#+begin_src elisp :tangle config.el
;; disable the graphical toolbar
(tool-bar-mode -1)
#+end_src
*** Modeline tweaks
Modeline is the Emacs equivalent of Vim's "Airline". You can do a lot to configure it. I just set the height though. I'm pretty sure this is in pixels.

#+begin_src elisp :tangle config.el
(setq doom-modeline-height 25)
#+end_src

Mucking with the colors is potentially cool, but I decided to not bother after futzing with it for a bit. Here's what I had.

#+begin_src elisp
; customize the mode-line (think airline in vim)
(set-face-attribute 'mode-line nil
 :background "#6c6f31" ; actually gets used as the foreground
 :foreground "#314d6f" ; actually....the background
 :box nil
 :overline nil
 :underline nil
 )

(set-face-attribute 'mode-line-inactive nil
                    :background "#4872a4"
                    :foreground "#1a283a"
                    :box nil    ; could do something like '(:line-width 8 :color "#565063")
                    :overline nil
                    :underline nil)
#+end_src

** Command w should be consistent
Sometimes command+w closes a workspace. Sometimes it closes the window.
I want it to _only_ get rid of the workspace and _never_ close the window
(unless maybe it's the only one).
By default this is mapped to +workspace/close-window-or-workspace

#+begin_src elisp :tangle config.el
(global-set-key (kbd "s-w")  '+workspace/delete)
#+end_src

** Selection Helper
[[https://github.com/magnars/expand-region.el][expand-region.el]] can "expand" or "contract" the current selection.

This has been mapped to Ctrl plus + (to expand) and = to get smaller. The same key just with and without holding down shift.

#+begin_src elisp :tangle config.el
; Ctrl + =/+ contracts or expands visual selection
(map! :nv "C-=" #'er/contract-region
      :nv "C-+" #'er/expand-region)
#+end_src

** Tab Bar mode
I don't remember why, but my notes say that I need to set the ~display-buffer-base-action~ to ~nil~ because i use ~tab-bar-mode~

I don't really understand what this does, & I don't want to wrap my head around it at the moment, but I'm pretty sure i should keep it. Here are the docs for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Choice.html][display-buffer's window choice]] which is one of the few pages that mentions ~display-buffer-base-action~ if you, or future me, feel like figuring this out.

#+begin_src elisp :tangle config.el
(setq display-buffer-base-action '(nil))
#+end_src

** Toggling the contents of splits
[[https://www.emacswiki.org/emacs/buffer-move.el][buffer-move]] allows you to swap contents of splits in a given direction.

If you're in the bottom one, you can use ~buf-move-up~ to swap it with the one above. If you're on the left use ~buf-move-right~, and so on.

#+begin_src elisp :tangle config.el
; from the bottom buffer swap its contents with the top
(global-set-key (kbd "<C-S-up>")     'buf-move-up)
; and vice-versa
(global-set-key (kbd "<C-S-down>")     'buf-move-down)
; and so on…
(global-set-key (kbd "<C-S-left>")   'buf-move-left)
(global-set-key (kbd "<C-S-right>")  'buf-move-right)
#+end_src

If you just want to toggle contents without thinking about direction there's Toggle Window Split. It was created by JeffDWork and shared on the [[https://www.emacswiki.org/emacs/ToggleWindowSplit][Emacs Wiki]]. It swaps the contents of each half of a split window.

The ~toggle-window-split~ function is bound to the C-x 4 prefix key. Whatever that is.

#+begin_src elisp :tangle config.el
;; Toggle Window Split by JeffDWork
;; found here: https://www.emacswiki.org/emacs/ToggleWindowSplit
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
	     (next-win-buffer (window-buffer (next-window)))
	     (this-win-edges (window-edges (selected-window)))
	     (next-win-edges (window-edges (next-window)))
	     (this-win-2nd (not (and (<= (car this-win-edges)
					 (car next-win-edges))
				     (<= (cadr this-win-edges)
					 (cadr next-win-edges)))))
	     (splitter
	      (if (= (car this-win-edges)
		     (car (window-edges (next-window))))
		  'split-window-horizontally
		'split-window-vertically)))
	(delete-other-windows)
	(let ((first-win (selected-window)))
	  (funcall splitter)
	  (if this-win-2nd (other-window 1))
	  (set-window-buffer (selected-window) this-win-buffer)
	  (set-window-buffer (next-window) next-win-buffer)
	  (select-window first-win)
	  (if this-win-2nd (other-window 1))))))

(define-key ctl-x-4-map "t" 'toggle-window-split)
#+end_src

There's also a ~toggle-frame-split~ function. I've copied it below to have a backup, but I don't have this enabled.

#+begin_src elisp
(defun toggle-frame-split ()
  "If the frame is split vertically, split it horizontally or vice versa.
Assumes that the frame is only split into two."
  (interactive)
  (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
  (let ((split-vertically-p (window-combined-p)))
    (delete-window) ; closes current window
    (if split-vertically-p
        (split-window-horizontally)
      (split-window-vertically)) ; gives us a split with the other window twice
    (switch-to-buffer nil))) ; restore the original window in this part of the frame

;; I don't use the default binding of 'C-x 5', so use toggle-frame-split instead
(global-set-key (kbd "C-x 5") 'toggle-frame-split)
#+end_src
** Cursors should follow the actual line
By default when you tell emacs to go to the end of the line it goes to the end of the /visual/ line, instead of the actual end of the line. I don't know why anyone thought this was a good default.

#+begin_src elisp :tangle config.el
; make the cursor go to the actual end of the line
; instead of the VISUAL end of the line. ugh.
(setq evil-respect-visual-line-mode nil)
(global-visual-line-mode t)
#+end_src

** Make URLs clickable
So you /can/ easily make urls clickable with ~(goto-address-mode t)~, /but/ you shouldn't, because there's ~orglink-mode~ which is better. See packages.el to turn that on.

** Folding
[[https://github.com/emacsorphanage/yafolding][yafolding]] is Yet Another Folding extension for Emacs which folds code based on indentation. This is helpful for languages like ruby where function bodies aren't bounded by simple things like curly braces. There's a screenshot of it in action in the repo's README.


#+BEGIN_SRC elisp :tangle config.el
;; yafolding
;; https://github.com/emacsorphanage/yafolding
(defvar yafolding-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "<C-S-return>") #'yafolding-hide-parent-element)
    (define-key map (kbd "<C-M-return>") #'yafolding-toggle-all)
    (define-key map (kbd "<C-return>") #'yafolding-toggle-element)
    map))
                                        ; we're usually not in yafolding-mode so...
(let ((map global-map))
  (define-key map (kbd "C-c f") #'yafolding-toggle-element))

(add-hook 'prog-mode-hook
          (lambda () (progn
		       (yafolding-mode)
                       ; private commments is unrelated
		       (private-comments-mode)
		       )))

(defun sg-toggle-fold ()
  "Toggle code folding according to indentation of current line."
  (interactive)
  (set-selective-display
   (if selective-display
       nil
     (save-excursion
       (back-to-indentation)
       (1+ (current-column))))))
       #+END_SRC


* Code Navigation
[[https://github.com/abo-abo/avy][avy]] is a way to jump to other visible sections of your code. It creates a visual layer with some overlayed characters and you type the characters next to the bit you want to jump to. There are some browser extensions that do this too, and I've found them very useful.

Instructions for the following code originated in [[https://github.com/doomemacs/doomemacs/issues/1643][this issue in the Doom Emacs repo]].

#+begin_quote
In case you're looking for more, you'll find many avy-ified evil motions on
the gs prefix, e.g. gsw, gsa (jump to an argument in a comma-delimited
argument list), and (a community favorite) g s SPC, which invokes
avy-goto-char-timer across all open windows. There's also gs/ for
avy-goto-char-timer restricted to the current window. - hlissner
#+end_quote

#+BEGIN_SRC elisp :tangle config.el
;; avy (jumping to visible text using a char-based decision tree.)
(map!
 :nv "C-f" #'avy-goto-char
 :nv "C-s" #'avy-goto-char-2
 :nv "C-d" #'avy-goto-line
 )
#+END_SRC


* Dired
By default Dired shows you owner permissions info. I /never/ want this. If I care about file permissions I'm in my shell, not dired. This removes them, courtesy of [[http://xahlee.info/emacs/emacs/emacs_dired_tips.html][Xah Lee]].

#+BEGIN_SRC elisp :tangle config.el
;; dired: hide user permission details
(defun masu-dired-mode-setup ()
	"hook for 'dired-mode'"
	(dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'masu-dired-mode-setup)
#+END_SRC

* Private Comments
Sometimes you want to leave a comment in some code but don't want to commit it for everyone else. Maybe it's a reminder of what you were doing. Maybe it's a reminder about something you always stumble over.

That's what [[https://github.com/masukomi/private_comments][Private Comments]] enables. [[https://github.com/masukomi/private-comments-mode#readme][It's emacs extension is here]].

This code controls the colors it's displayed with.

#+BEGIN_SRC elisp :tangle config.el
(with-eval-after-load "private-comments-mode"
  (set-face-background 'private-comments-face "#527568")
  (set-face-foreground 'private-comments-face "#FFFFFF"))
#+END_SRC

The code that actually enables it is in the pro-mode hook up in my Yafolding section.
* Org-mode
The world's greatest writing tool.
"All hail the power of org-mode."
"Hail! Hail!"

** Temporary Hacks
[[https://github.com/doomemacs/doomemacs/issues/6478][There's a bug in evil-search]] where searches in org-mode ignore results in folded sections. What follows is a temporary fix until that bug is fixed. It uses ~isearch~ as the evil search module.

Bug reported: June 20, 2022
Last time I checked: July 5, 2024

#+begin_src elisp :tangle config.el
(setq org-fold-core-style 'text-properties)
(after! evil
   (evil-select-search-module 'evil-search-module 'isearch))
#+end_src

** Pretty bullet lists please
[[https://github.com/sabof/org-bullets][org-bullets]] mode takes those boring-ass ASCII characters used for headings and bullets and replaces them with UTF-8 characters that look way better. This is just a visual tweak. The file stores the boring ASCII characters. That way if you an org-mode file with some poor soul who hasn't learned the joys of emacs, or how to make their bullets pretty, they can still read them without issue.

#+BEGIN_SRC elisp :tangle config.el
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

** Keyboards are great, but mice are nice too.
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/org-mouse.el][Org-mouse]] (ships with emacs) implements the following features:
- following links with the left mouse button (in Emacs 22)
- subtree expansion/collapse (org-cycle) with the left mouse button
- several context menus on the right mouse button:
   + general text
   + headlines
   + timestamps
   + priorities
   + links
   + tags
- promoting/demoting/moving subtrees with mouse-3
   + if the drag starts and ends in the same line then promote/demote
   + otherwise move the subtree

#+begin_src elisp :tangle config.el
(require 'org-mouse)
#+end_src
** Make it understand your Vim based muscle memory.
[[https://github.com/Somelauw/evil-org-mode][evil-org-mode]] provides "Supplemental evil-mode key-bindings to Emacs org-mode."

tl;dr: it makes org-mode work the way us Vim expats expect.

#+BEGIN_SRC elisp :tangle config.el
(use-package evil-org
  :ensure t
  :after (evil org)
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook
            (lambda ()
              (evil-org-set-key-theme '(navigation insert textobjects additional calendar))))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+END_SRC


#+begin_src elisp :tangle config.el

#+end_src

This downloads the image as a temp file so that emacs can load it visually into the page. That's why it doesn't work on GitHub rendered pages.

The full image link tag looks like this:

#+begin_src
[[image-url:https://example.com/cat.jpg]]
#+end_src

And here it is in practice. If you're me, clicking this replaces the current buffer with an image of a cat. If you're reading this on GitHub it isn't going to work.

[[image-url:https://d1ra4hr810e003.cloudfront.net/media/27FB7F0C-9885-42A6-9E0C19C35242B5AC/0/D968A2D0-35B8-41C6-A94A0C5C5FCA0725/F0E9E3EC-8F99-4ED8-A40DADEAF7A011A5/dbe669e9-40be-51c9-a9a0-001b0e022be7/thul-IMG_2100.jpg][example cat]]

There are also functions to add an image as an overlay or remove one, but I've had trouble getting them to work.

#+begin_src elisp :tangle config.el
(defun image-url-overlays ()
  "Put image overlays on remote image urls."
  (interactive)
  (loop for image-url in (org-element-map (org-element-parse-buffer) 'link
               (lambda (link)
                 (when (string= "image-url" (org-element-property :type link))
                   link)))
    do
    (let* ((path (org-element-property :path image-url))
           (ov (make-overlay (org-element-property :begin image-url)
                 (org-element-property :end image-url)))
           (img (create-image (expand-file-name
                   (concat (md5 path)
                       "."
                       (file-name-extension
                        path))
                   temporary-file-directory))))
      (overlay-put ov 'display img)
      (overlay-put ov 'image-url t))))

(defun image-url-clear-overlays ()
  "Reove overlays on image-urls."
  (interactive)
  (require 'ov)
  (ov-clear 'image-url))
#+end_src


Found [[https://emacs.stackexchange.com/a/26638/30947][on Stack Exchange]]

** Generating Tables of Contents
[[https://github.com/snosov1/toc-org/][toc-org]] gives you auto-generated & updated tables of contents for org-mode. It supports markdown-mode too. /However/, Doom's ~init.el~ has [[https://docs.doomemacs.org/v21.12/modules/lang/markdown/][markdown support]] built-in which uses [[https://github.com/ardumont/markdown-toc][markdown-toc]] for generating tables of content in markdown files and if you turn markdown support on in toc-org there are disagreements about ~markdown-mode-map~ so I just leave it off.

Honestly, life is better when I just write in org-mode and export to markdown.



#+begin_src elisp :tangle config.el
; enable table of contents generation in org-mode
(if (require 'toc-org nil t)
    (progn
      (add-hook 'org-mode-hook 'toc-org-mode))
      ;(add-hook 'markdown-mode-hook 'toc-org-mode))
      ;; enable in markdown, too
      ; disabled because it thinks markdown-mode-map is a void
      ; variable
      ;(add-hook 'markdown-mode-hook 'toc-org-mode))
      ;(define-key markdown-mode-map (kbd "\C-c\C-o") 'toc-org-markdown-follow-thing-at-point)
  (warn "toc-org not found"))
#+end_src

*** Usage
1. create a heading for your table of contents to live under
2. with the cursor on that heading, run
   ~<SPACE m q>~ or ~<org-set-tags-command>~
3. set the TOC tag.
4. save. This save, and all future saves update the TOC.
5. profit!

** Org-babel
Org-babel is a component of org-mode that teaches it how to intellegently handle the content of source code blocks. If your language doesn't have built-in support, there's probably a package for it.

*** ob-raku (raku support)
The [[https://github.com/masukomi/ob-raku][ob-raku package]] is not currently in melpa. But, it works fine and adds support for [[https://raku.org/][Raku]] to org-mode.

I'm the maintainer of this repo, and - for reasons I've forgotten - I haven't gotten it into melpa yet.

If you want Raku support in your org-mode then just use the following but change the path to your local copy of the repo.

#+begin_src elisp :tangle config.el
; teach org-babel about Raku
; ⚠ note that this path is to my local clone of the ob-raku repo.
(let ((ob-raku-el "~/workspace/reference/emacs/ob-raku/ob-raku.el"))
 (when (file-exists-p ob-raku-el)
    (load-file ob-raku-el)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)
       (raku . t))
     )
   )
)
#+end_src

Here's where we tell it to load the shell language? I think? I failed to leave myself a note explaining this.

#+begin_src elisp :tangle config.el
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t))
 )
#+end_src

*** Fontified source code blocks
[[https://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html][theming for org-babel source code blocks]] is possible, but I don't really understand it.

In theory, the following will format your source code according to the styles you've set up for the language being used.

It's not "tangled" here because I set it later in a batch.

#+begin_src elisp
;; fontify code in code blocks
(setq org-src-fontify-natively t)
#+end_src

** Sometimes I don't spell gud.
Enable flyspell in text modes

#+BEGIN_SRC elisp :tangle config.el
(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
#+END_SRC

** Configuring misc things via global org variables


First let's disable the interpretation of ~_~ and ~^~ as subscript & superscript
which causes issues when exporting as markdown.


#+begin_src elisp :tangle config.el
  (setq org-export-with-sub-superscripts nil)
#+end_src

Then we'll define our "todo keywords" and tell org-mode what colors we want them displayed in.

#+begin_src elisp :tangle config.el
  ; KEYWORDS
  (setq
    org-todo-keywords
    '((sequence "TODO(t)" "INPROGRESS(i)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")
    (sequence "[ ](T)" "|" "[X](D)")
    (sequence "|" "OKAY(o)" "YES(y)" "NO(n)"))

    org-todo-keyword-faces '(
    ("TODO"    :foreground "#7c7c75" :weight normal :underline t)
    ("WAITING"  :foreground "#9f7efe" :weight normal :underline t)
    ("INPROGRESS"  :foreground "#0098dd" :weight normal :underline t)
    ("DONE"    :foreground "#50a14f" :weight normal :underline t)
    ("CANCELLED"  :foreground "#ff6480" :weight normal :underline t)
    )
  )
#+end_src

The information to be shown in org-agenda is normally collected from /all/ the agenda files. The ~org-agenda-files~ variable defines where those files are stored. If it's a string, instead of a list, they'll all be stored in the same file.

In my case =~/Documents/notes= is where all my Denote (see below) files go.

~org-directory~ defines where org files are typically located. It needs to be defined before org loads.

#+begin_quote
Org acutally uses this variable only under rare circumstances, like when filing remember notes in an interactive way and prompting you for an Org file to put the note into. - [[https://orgmode.org/worg/org-configs/org-customization-guide.html][Org customization guide]]
#+end_quote


#+begin_src elisp :tangle config.el
(setq
  org-agenda-files '("~/Documents/notes/"
                     "~/.config/org/")
  ; DEBATING if ^^ and vvv should be the same directory
  ; org-directory needs to be set before org loads
  org-directory "~/.config/org/"
)
#+end_src

Next we'll configure all the default files. As noted below, I don't actually use the notes stuff, because I use [[https://protesilaos.com/emacs/denote][Denote]] (see below). I like having good defaults though.

Org-agenda's todo functionality is pretty cool though. The last line of this block adds a timestamp when marking a TODO item as done.

#+begin_src elisp :tangle config.el
(setq
  org-default-notes-file (concat org-directory "notes.org")
  +org-capture-notes-file (concat org-directory "notes.org")
  ; use denote instead for journal stuff
  +org-capture-notes-file (concat org-directory "journal.org")
  +org-capture-todo-file (concat org-directory "todo.org")

  ; org-log-done adds a timestamp when marking a todo item as done
  org-log-done t
)
#+end_src

The following will start everything off entirely folded. That is
to say, just showing headings, with their contents "folded" away. I go back and forth on whether this is a good thing or a bad thing. If it's not tangled, I'm currently on the "bad thing" side of the fence. 😉


#+begin_src elisp
(setq
  ; start off with things folded
  ; manually override in a file with
  ; #+STARTUP: showall
  ; #+STARTUP: fold
  org-startup-folded t
)
#+end_src

You can override this by adding a "showall" or "fold" instruction to a file's frontmatter.

#+begin_src
#+STARTUP: showall
#+end_src

This was discussed earlier. It's used by org-babel to make your code blocks look good.

#+begin_src elisp :tangle config.el
(setq
    ; syntax highlighting within org blocks
    org-src-fontify-natively t
)
#+end_src

I prefer it when org-mode just shows italic text as italic without the slashes that caused it to be italic. If you set this to ~nil~ it'll show the slashes that italicized it or asterisks that bolded it, or whatever.

#+begin_src elisp :tangle config.el
(setq
    ; Non-nil mean font-lock should hide the emphasis marker characters.
    ; e.g. / / for italics disappear
    org-hide-emphasis-markers t
)
#+end_src

Org can display remote images inline, but it's disabled by default, and as far as I can tell, it's not documented & it's only mentioned in release notes and online discussions. If you dig about ~16,000 into the source file you'll find it though. 🤦‍♀️

Your options are:
- ~skip~ - don't display them
- ~download~ - always download and display remote images
- ~cache~ - Display remote images, and open them in separate buffers for caching. This will also silently update the image buffer when a file change is detected.
- ~t~ - mentioned the inline docs, but not explained & not obvious from nearby code either.


#+begin_src elisp :tangle config.el
  (setq org-display-remote-inline-images 'cache)
#+end_src

Once you've got an image to display there's a question of how-wide. Preferably this is defined in an ~#+ATTR.*~ keyword by the image tag. For example: ~#+ATTR_HTML: :width 300px~

Without an ATTR hint it'll default to showing them at their original size. However, in my experience images are frequently /significantly/ larger than they need to be. ~org-image-actual-width~ is what controls the default behavior.

- ~nil~ - use the original image width
- non-nil & non-number - use the original image width. Why would you ever set this?
- an integer - defaults to the number specified (in pixels)

Note that this is overwritten by the ~auto-image-resize~ function later on (if I have it turned on). But again, good defaults are important.

~#+STARTUP: inlineimages~ is related according to my notes, but I
don't know why or how.

#+begin_src elisp :tangle config.el
(setq
  org-image-actual-width nil
  ; see auto-image-resize function below which will override this
  ; related #+STARTUP: inlineimages
)
#+end_src

** org-agenda
Oddly this doesn't have a default keybinding, but ~C-c a~ is what the community seems to have settled on as a default. So, let's enable that.

#+BEGIN_SRC elisp :tangle config.el

(global-set-key (kbd "C-c a") 'org-agenda)

#+END_SRC


** Automatic Image resizing
Same idea as "responsive design" in CSS. With this images will fill the width of the page regardless of what your page width is. This code comes from [[https://stackoverflow.com/a/73426792/13973][a Stack Overflow answer]].

I had this enabled, and I /think/ it mostly worked, but then I disabled it for some reason I don't remember. I don't use a lot of images in my documents so I'd forgotten all about this.

This will resize down whenever the window is < 80 columns

#+begin_src elisp :tangle config.el

 (defun org-image-resize (frame)
   (when (derived-mode-p 'org-mode)
       (if (< (window-total-qwidth) 80)
       (setq org-image-actual-width (window-pixel-width))
     (setq org-image-actual-width (* 80 (window-font-width))))
       (org-redisplay-inline-images)))
 (add-hook 'window-size-change-functions 'org-image-resize)
#+end_src

This will auto-resize ALL images whenever the window is resized
#+begin_src elisp
(defun org-image-resize (frame)
  (when (derived-mode-p 'org-mode)
      (setq org-image-actual-width
	    ; (window-pixel-width)
	    ; give it a 20 pixels bufer
	    (- (window-pixel-width) 60)
	    )
      (org-redisplay-inline-images)))

(add-hook 'window-size-change-functions 'org-image-resize)
#+end_src
** Slack / GitHub Style emoji
The [[https://github.com/iqbalansari/emacs-emojify][emacs-emojify]] offers support for Slack / GitHub style emojis, as well as easy insertion of other emojis.

By default it handles ascii, unicode, and "github" style emojis. This is controlled from the ~emojify-emoji-styles~ & ~emojify-display-style~ variables. I only want to display unicode emojis, but I want to be able to type ~:smile:~ and get the smile emoji without having to open a picker.


First you need the emojify package loaded. See ~packages.el~
Found in [[https://github.com/bgutter/dotemacs/blob/master/my-init.org][bgutter's config file]]

Then you turn it on everywhere, except where you don't want it.
#+BEGIN_SRC elisp :tangle config.el
(use-package emojify
  :config
  (when (member "Segoe UI Emoji" (font-family-list))
    (set-fontset-font
     t 'symbol (font-spec :family "Segoe UI Emoji") nil 'prepend))
  (setq emojify-display-style 'unicode)
  (setq emojify-emoji-styles '(unicode github))
  (global-set-key (kbd "C-c .") #'emojify-insert-emoji))

(add-hook 'after-init-hook #'global-emojify-mode)
(defun my:emojify-inhibit-fix-org-drawers (text beg end)
  "Since org-mode now uses lower-case :begin:, :end:, etc tags, some of them are
now being rendered as Emojis. Filter this case out."
  (and (equal major-mode 'org-mode) (member (downcase text) '(":begin:" ":end:"))))

; made by me
(defun my:emojify-inhibit-no-inline-escape-emoji (text beg end)
  "disable creation of emojis starting with = or ~ in org-mode"
  (and (equal major-mode 'org-mode)
       (or))
  (string-prefix-p "=" (downcase te))
  (string-prefix-p "~" (downcase te)))


(with-eval-after-load "emojify"
	(add-to-list 'emojify-inhibit-functions 'my:emojify-inhibit-fix-org-drawers)
	(add-to-list 'emojify-inhibit-functions 'my:emojify-inhibit-no-inline-escape-emoji)
)
#+END_SRC
** Exporters
Packages prefixed with ~ox-*~ are Org-mode eXporter packages. The most common ones are [[https://orgmode.org/worg/exporters/ox-overview.html][listed on the Org-mode site]] but there are quite a few others. Here are the ones I use.

- [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]]
  technically Hugo CAN render org-mode files, but it doesn't do a very good job. Much better to write in org-mode and export to Hugo's markdown flavor with the ~ox-hugo~ exporter.
- [[https://github.com/jkitchin/ox-clip][ox-clip]]
  copies selected regions in org-mode as formatted text on the clipboard that can be pasted into other applications.
- [[https://github.com/emacsmirror/org/blob/master/lisp/ox-md.el][ox-md]]
  exports to standard Markdown
- [[https://github.com/larstvei/ox-gfm][ox-gfm]]
  exports to GitHub flavored Markdown
- ox-publish
  This one is built into emacs and it's for converting a collection of org files into a static web site. There's a [[https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][tutorial here]] and [[https://orgmode.org/manual/Publishing.html][documentation here]]. I haven't actually used this one, because I typically want the capabilities of a Hugo site. I especially like the aspect of looking good without spending a billion hours crafting CSS.

  #+begin_quote
  ox-publish.el can do the following:
    - Publish all one's Org files to a given export backend
    - Upload HTML, images, attachments and other files to a web server
    - Exclude selected private pages from publishing
    - Publish a clickable sitemap of pages
    - Manage local timestamps for publishing only changed files
    - Accept plugin functions to extend range of publishable content
  #+end_quote

  #+begin_src
  #+end_src

#+begin_src elisp :tangle config.el
(with-eval-after-load 'ox
  (require 'ox-hugo)
  (require 'ox-gfm nil t)
  (require 'ox-md)
  (require 'ox-clip)
  (require 'ox-publish)
  (require 'ox-slack))

#+end_src

*** Hugo
ox-hugo is good, but it doesn't know how to generate relative links in Hugo's weird cross-reference way. The trick is that, without reading the frontmatter of the file you're linking to, & pondering how Hugo will interpret that, you don't know the final url of the page you're linking to.

Hugo's solution to that is the [[https://gohugo.io/content-management/cross-references/][ref & relref]] shortcodes. This allows you to create ~ref~ shortcode links. To use this I…

1. use =C-c l= to insert a link
2. choose / type =ref:= or =relref:=
3. hit return, and navigate to the path of the other file under hugo's =content= directory.
4. select the file I want
5. enter a description.

When I export it will convert it to a markdown style link with the =ref= / =relref= shortcode.


#+begin_src elisp :tangle config.el
(with-eval-after-load 'org
  (org-link-set-parameters
   "relref"
   :complete (lambda ()
               (concat
                "relref:"
                (file-name-nondirectory (read-file-name "File: "))
                )
               )

   :export (lambda (path description backend)
             (format "[%s]({{< relref %s >}})" description path  )
        )
   )

  (org-link-set-parameters
   "ref"
   :complete (lambda ()
               (concat
                "ref:"
                (file-name-nondirectory (read-file-name "File: "))
                )
               )

   :export (lambda (path description backend)
             (format "[%s]({{< ref %s >}})" description path  )
        )
   )

)
#+end_src

Note that there is no =:follow= function set. Clicking on these links in org-mode won't go anywhere. This is intentional because the link is going to the markdown file used when the site is generated, but I don't know where the org-mode file used to generate that markdown file is, and /that/ is the file you'd want to open.


If you're using the built-in org-mode support /instead/ of ox-hugo you could use something like this.

#+BEGIN_SRC elisp
;; New link type for Org-Hugo internal links
(with-eval-after-load 'ox-hugo
  (org-link-set-parameters "hugo"
		           :complete (lambda ()
			               (concat "{{% ref "(file-name-nondirectory (read-file-name "File: "))" %}}"))))
#+END_SRC

See also the timestamp tweak in the next section.

** Time Stamps, & Graphs, inline images


#+begin_src elisp :tangle config.el
(with-eval-after-load 'org
	;; org-hugo blogging things
	(setq time-stamp-active t
		time-stamp-start "#\\+hugo_lastmod:[ \t]*"
		time-stamp-end "$"
		time-stamp-format "%04Y-%02m-%02d"
                org-hugo-auto-set-lastmod t)
	(add-hook 'before-save-hook 'time-stamp nil)
	(add-to-list
		'org-src-lang-modes '("plantuml" . plantuml))
	(org-add-link-type
		"image-url"
		(lambda (path)
		(let ((img (expand-file-name
				(concat (md5 path) "." (file-name-extension path))
				temporary-file-directory)))
		(if (file-exists-p img)
		(find-file img)
			(url-copy-file path img)
			(find-file img)))))

  )
#+end_src

*** Image links
Sometimes you want an image that's visible in your document and is /also/ a link to something else. This teaches emacs a new link type called ~image-url~ which downloads temp files locally for emacs to load and display.

Because of this hacky nature, it's not for files that you'll be exporting or sharing with others. This is for personal use only. Maybe in your [[https://protesilaos.com/emacs/denote][Denote]] (see below) or [[https://www.orgroam.com/][Org-roam]] files.

This is enabled via the ~(org-add-link-type "image-url"…)~ call above.

⚠ DO NOT USE THIS FOR FILES THAT GitHub WILL RENDER

*** PlantUML
[[https://plantuml.com/][PlantUML]] is a kind-of 🤯 mind-blowingly capable text to graph system. It blows Mermaid.js out of the water. [[https://github.com/skuro/plantuml-mode][PlantUML mode]] is the emacs tool. In the last section we informed org-mode that ~plantuml~ was a supported source language.

supported diagram types: uml, sequence, usecase, class, object, activity, component, deployment, state, & timing.

In the ~packages.el~ file we're loading ~plantuml-mode~ & ~flycheck-plantuml~

Enable plantuml-mode for ~*.plantuml~ files. This isn't org specific, but I only ever use PlantUML inside org so...
#+begin_src elisp :tangle config.el
;; Enable plantuml-mode for PlantUML files
(add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
#+end_src

⚠ WARNING: previewing of files may result in info being sent to plantuml.com. if execution mode is "server". You can customize ~plantuml-default-exec-mode~ or run ~plantuml-set-exec-mode~ from a plantuml-mode buffer to switch modes.

To avoid this use executable mode or install the jar (note) homebrew installs the jar
the plantuml-server-url defaults to "https://www.plantuml.com/plantuml"

The executable should work if you have run ~brew install plantuml~
BUT it seems like babel wants jar, so 🤷‍♀️

To find this you
1. run ~brew --prefix plantuml~
2. ~cd~ to the directory that spits out
3. run ~find . -name "*.jar"~
4. combine the path in step 1 with the output of find.
5. stick that in the ~plantuml-jar-path~ and the ~org-plantuml-jar-path~
   The path I got is shown below.

#+begin_src elisp :tangle config.el
(setq plantuml-set-exec-mode "executable"); because babel needs the jar i think

;; Sample jar configuration
(setq plantuml-jar-path "/opt/homebrew/opt/plantuml/libexec/plantuml.jar")
(setq plantuml-default-exec-mode 'jar)
#+end_src

Now that we've got PlantUML installed & the paths configured we need to finish instructing Org-Mode on how to integrate it. More details [[http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html][where I found this code]].

#+begin_src elisp :tangle config.el
;; active Org-babel languages
(org-babel-do-load-languages 'org-babel-load-languages
 '(;; other Babel languages
   (plantuml . t)))

(setq org-plantuml-jar-path "/opt/homebrew/opt/plantuml/libexec/plantuml.jar")
#+end_src

**** Usage
create a source block with the plantuml language ~#+begin_src plantuml~ . Inside the block enter ~C-c '~ to open a PlantUML buffer. When you're done in the buffer type ~C-'~ to return.

Default Key Bindings:

- ~C-c C-c~  plantuml-preview: renders a PlantUML diagram from the current buffer in the best supported format
- ~C-u C-c C-c~  plantuml-preview in other window
- ~C-u C-u C-c C-c~ plantuml-preview in other frame

* Evil Mode
** evil-surround
Tim Pope - patron saint of Vim users - wrote a cool tool called [[https://github.com/tpope/vim-surround][surround.vim]]

#+begin_quote
Surround.vim is all about "surroundings": parentheses, brackets, quotes, XML tags, and more. The plugin provides mappings to easily delete, change and add such surroundings in pairs.
#+end_quote

Check out the [[https://github.com/tpope/vim-surround][surround.vim README]] better understand what this means.

[[https://github.com/emacs-evil/evil-surround][evil-surround]] is a reimplementation of the same idea in Emacs.

#+begin_src elisp :tangle config.el
; a port of Tim Pope's surround.vim
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))

(add-hook 'yaml-mode-hook
          (lambda ()
            (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
#+end_src
*** Usage
**** Add surrounding
You can surround in visual-state with =S<textobject>= or =gS<textobject>=. Or in normal-state with =ys<textobject>= or =yS<textobject>= .

**** Change surrounding
You can change a surrounding with =cs<old-textobject><new-textobject>= .

**** Delete surrounding
You can delete a surrounding with =ds<textobject>= .
**** More
additional things like adding custom pairs is described in detail in the [[https://github.com/emacs-evil/evil-surround#readme][evil-surround readme]]
* Denote
[[https://protesilaos.com/emacs/denote][Denote]] is a personal note-taking system akin to Obsidian. Within emacs its biggest competitor is [[https://www.orgroam.com/][Org-roam]].

** An aside about Org-roam
I feel the need to put this here because Org-roam significantly overshadows Denote despite - in my opinion - being significantly worse.

Org-roam gets all the press for two reasons:

1. They put in a lot of effort to making a good site, a cool logo, and other /good/ marketing stuff.
2. It has a fancy graph like Obsidian that everyone "Oos" and "Ahhhs" over and then promptly tells you they never actually use. It's just pretty to look at.

Once they had that, lots of people started trying it, and then making videos about it, and it became increasingly visible as a result.

I don't recommend Org-roam because it stores everything in a SQLite database which has broken on me twice, in a way i can't fix. I love SQLite, but there's something effed up in how it's being used here.

** Back to denote
Denote takes the "unix philosophy"…

#+begin_quote
- Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new "features".
- Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input.

Doug Mcllroy
#+end_quote

…and applies it within the environment of emacs.

The end result is absolutely amazing, but the Denote itself is mostly just connecting existing things in a clean and coherent way. It does everything you need from a system like this, and yet manages to do it with /no/ database or other external dependencies.

If you haven't done so already, watch the [[https://youtu.be/mLzFJcLpDFI][introduction to denote]] video, by its creator. It's not flashy, but it's impressive as hell.

In addition, it's made to be hackable if you've got the skills to do so.

#+begin_quote
Denote’s code base consists of small and reusable functions. They all have documentation strings. The idea is to make it easier for users of varying levels of expertise to understand what is going on and make surgical interventions where necessary (e.g. to tweak some formatting). - Protesilaos Stavrou
#+end_quote

Honestly, Denote "just works" for me and I've never felt the need. The ONLY thing I've tweaked is how dired shows files, because - Unix philosophy here - Denote doesn't have its own file listing code. It just piggy-backs on [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] for that. I told dired to stop showing me the unix permissions of each file.

I think someone needs to give it a good logo and a web site so that it can compete with.

** My Denote config
Sorry. I wasn't expecting /that/ side-trip. Here's how I've set mine up.

After requiring it I need to tell it where to store the files. Quick aside: It can use Markdown files, but why would you do that when you have Org-mode?!


#+BEGIN_SRC elisp :tangle config.el
; BEGIN DENOTE STUFF
(require 'denote)

(setq denote-directory (expand-file-name "~/Documents/notes/"))
#+END_SRC

Keywords can be anything. The examples are emacs, philosophy, politics, economics, food, & drink. The keywords you choose end up being applied to the file names, and file names are the "cornerstone" of Denote. I've got 3 really boring ones, but my actual keywords list is really long, because I've set ~denote-infer-keywords~ to true. When you do that, it learns new keywords from the titles of the files you create. I have no idea where it's saving these.

~denote-sort-keywords~ being non-nil means that when it shows me the list of them it'll be alphabetically sorted. Technically it's whatever ~string-lessp~ sorting produces. Fortunately it's got filtering so you just start typing the keyword and it'll filter the list down to just the things that match which you can then select. You can, of course, tag a file with multiple keywords.

#+BEGIN_SRC elisp :tangle config.el
(setq denote-known-keywords '("daily" "todo" "project"))
(setq denote-infer-keywords t)
(setq denote-sort-keywords t)
;; We allow multi-word keywords by default.  The author's personal
;; preference is for single-word keywords for a more rigid workflow.
(setq denote-allow-multi-word-keywords nil)
#+END_SRC

When we create a new note ( ~C-c n n~ ) , I want it to be in org-mode - duh - and that's the default. And i want it to prompt me for a title, and then keywords. In the "frontmatter" it's going to set a date format. By default it's setting it based on the file type. A decision I don't understand, but don't have an opinion about either. I go with the defaults.

- For Org, an inactive timestamp is used, such as =[2022-06-30 Wed 15:31]= .
- For Markdown, the RFC3339 standard is applied: =2022-06-30T15:48:00+03:00= .
- For plain text, the format is that of ISO 8601: =2022-06-30= .

There are [[https://protesilaos.com/emacs/denote#h:7f918854-5ed4-4139-821f-8ee9ba06ad15][instructions to change the frontmatter]] but I've never felt the need.

#+BEGIN_SRC elisp :tangle config.el
(setq denote-file-type nil) ; Org is the default, set others here
(setq denote-prompts '(title keywords))
(setq denote-date-format nil) ; read doc string
#+END_SRC

Denote lets you easily insert links to other denote notes, and headings within them (org-mode only). If you want it to prompt you to choose a heading you can set ~denote-org-extras-link-to-heading~ I don't use a lot of cross-linking so I don't have an opinion here & I leave it off.


Backlinks (links to the current file) can be can be displayed in a buffer. The configuration below is invoked with ~C-c n b~, and after a moment of searching it opens a small lower split with a listing of all the files that link to the current one.

You can control its placement with the ~denote-link-backlinks-display-buffer-action~ /but/ the docs warn that mucking with that is advanced. I don't know jack about emacs internals, so I'm not touching that.

I have no idea where i found ~denote-link-fontify-backlinks~, but my notes claim that "By default, we fontify backlinks in their bespoke buffer." It doesn't appear in the docs though. I do know that it's definitely "fontified" (highlighted the different sections differently) in the backlinks buffer, so it appears to be working.

Org-mode is going to display links as "buttons" straight out of the box, but if you use markdown or plain-text files you'll need to add a hook to the ~denote-link-buttonize-buffer~ function. I don't need this, but it seemed nice to have in case I /do/ use some non-org files in Denote. Hah, as if!.

I failed to leave myself a note about ~denote-dired-rename-expert~ I have no idea what it does and it's not in the docs.

#+begin_quote
 One of the upsides of Denote’s file-naming scheme is the predictable pattern it establishes, which appears as a near-tabular presentation in a listing of notes (i.e. in Dired). The denote-dired-mode can help enhance this impression, by fontifying the components of the file name to make the date (identifier) and keywords stand out.
#+end_quote


If you use Denote files in directories all over your computer you can say ~(add-hook 'dired-mode-hook #'denote-dired-mode)~, but if you want to restrict the Denote "fontification" to files in a limited set of directories it's a little more configuration. The ~dired-mode-in-directories~ and ~denote-dired-directories~ work together to do fine tune where this is applied. However there's a much easier way.

#+BEGIN_SRC elisp :tangle config.el
(setq denote-link-fontify-backlinks t)
(add-hook 'find-file-hook #'denote-link-buttonize-buffer)
(setq denote-dired-rename-expert nil)



(setq denote-dired-directories
      (list denote-directory
            (thread-last denote-directory (expand-file-name "attachments"))
                                          (expand-file-name "~/Documents/notes")
            ))
(add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)
#+END_SRC

#+begin_quote
While it is possible to use the generic denote command to maintain a journal, [Denote Provides] an optional set of convenience options and commands as part of ~denote-journal-extras.el~.
To use those, add the following the Denote configuration: ~(require 'denote-journal-extras)~
#+end_quote

I don't use denote for journaling (🤔 maybe I should) but here are some useful functions if you want to try. It should be noted that it has support for [[https://zettelkasten.de][Zettelkasten]] style journaling built in.

#+BEGIN_SRC elisp :tangle config.el
(defun denote-dated-journal ()
  "Create an entry tagged 'journal', while prompting for a title."
  (interactive)
  (denote
   (denote--title-prompt)
   '("journal")))

(defun denote-journal ()
  "Create an entry tagged 'journal' with the date as its title."
  (interactive)
  (denote
   (format-time-string "%A %e %B %Y") ; format like Tuesday 14 June 2022
   '("journal"))) ; multiple keywords are a list of strings: '("one" "two")
#+END_SRC

You can also integrate denote into [[https://orgmode.org/manual/Capture.html][org-capture]].

#+begin_src elisp :tangle config.el
(setq denote-org-capture-specifiers "%l\n%i\n%?")
(with-eval-after-load 'org-capture
  (add-to-list 'org-capture-templates
               '("n" "New note (with Denote)" plain
                 (file denote-last-path)
                 #'denote-org-capture
                 :no-save t
                 :immediate-finish nil
                 :kill-buffer t
                 :jump-to-captured t)))
#+end_src


*** Usage stuff
I generally open the list of Denote notes with ~C-c n f~ which comes from the ~show-denote-dir~ function below.

Unlike many packages, denote defines NO key bindings itself. I've chosen to go with the defaults which are all "submenus", or "subcommands", or whatever helm calls its wee window hierarchy things, under ~C-c n~

#+BEGIN_SRC elisp :tangle config.el
(defun show-denote-dir ()
  "open an dired window on the default denote directory"
  (interactive) ; required to make it accessible via keybdingings
  ;; (split-window-vertically)
  ;; (other-window 1)
  (dired denote-directory))

;; Denote DOES NOT define any key bindings.  This is for the user to
;; decide.  For example:
(let ((map global-map))
  (define-key map (kbd "C-c n f") #'show-denote-dir)   ; custom
  (define-key map (kbd "C-c n j") #'denote-journal) ; custom
  (define-key map (kbd "C-c n n") #'denote)
  (define-key map (kbd "C-c n N") #'denote-type)
  (define-key map (kbd "C-c n d") #'denote-date)
  (define-key map (kbd "C-c n s") #'denote-subdirectory)
  ;; If you intend to use Denote with a variety of file types, it is
  ;; easier to bind the link-related commands to the `global-map', as
  ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
  ;; `markdown-mode-map', and/or `text-mode-map'.
  (define-key map (kbd "C-c n i") #'denote-link) ; "insert" mnemonic
  (define-key map (kbd "C-c n I") #'denote-link-add-links)
  (define-key map (kbd "C-c n l") #'denote-link-find-file) ; "list" links
  (define-key map (kbd "C-c n b") #'denote-link-backlinks)
  ;; Note that `denote-dired-rename-file' can work from any context, not
  ;; just Dired bufffers.  That is why we bind it here to the
  ;; `global-map'.
  (define-key map (kbd "C-c n r") #'denote-dired-rename-file)
  (define-key map (kbd "C-c n R") #'denote-dired-rename-file-and-add-front-matter))

;; Key bindings specifically for Dired.
(let ((map dired-mode-map))
  (define-key map (kbd "C-c C-d C-i") #'denote-link-dired-marked-notes)
  (define-key map (kbd "C-c C-d C-r") #'denote-dired-rename-marked-files)
  (define-key map (kbd "C-c C-d C-R") #'denote-dired-rename-marked-files-and-add-front-matters))
; END DENOTE STUFF
#+END_SRC

* Language Specific Things
** Elixir
…is a language I should use more.

Highlighting of Elixir's Inline LiveView templates via [[https://blog.evalcode.com/phoenix-liveview-inline-syntax-highlighting-for-emacs/][this post]] by Justin Smestad.

Assumes web-mode and elixir-mode are already set up

#+begin_src elisp :tangle config.el
;;------------- ELIXIR
; highlight inline LiveView templates
(use-package polymode
  :mode ("\.ex$" . poly-elixir-web-mode)
  :config
  (define-hostmode poly-elixir-hostmode :mode 'elixir-mode)
  (define-innermode poly-liveview-expr-elixir-innermode
    :mode 'web-mode
    :head-matcher (rx line-start (* space) "~L" (= 3 (char "\"'")) line-end)
    :tail-matcher (rx line-start (* space) (= 3 (char "\"'")) line-end)
    :head-mode 'host
    :tail-mode 'host
    :allow-nested nil
    :keep-in-mode 'host
    :fallback-mode 'host)
  (define-polymode poly-elixir-web-mode
    :hostmode 'poly-elixir-hostmode
    :innermodes '(poly-liveview-expr-elixir-innermode))
  )
(setq web-mode-engines-alist '(("elixir" . "\\.ex\\'")))
#+end_src

I'm using ~reformatter~ to auto-format Elixir code. You can find out more details about that & other tips for Elixir development in Emacs [[https://medium.com/@victor.nascimento/elixir-development-on-emacs-9f6776265e4d][in this helpful blog post]] by Victor Nascimento.

#+begin_src elisp :tangle config.el
(use-package reformatter
  :ensure t
  :config
  ; Adds a reformatter configuration called "+elixir-format"
  ; This uses "mix format -"
  (reformatter-define +elixir-format
    :program "mix"
    :args '("format" "-"))
  ; defines a function that looks for the .formatter.exs file used by mix format
  (defun +set-default-directory-to-mix-project-root (original-fun &rest args)
    (if-let* ((mix-project-root (and buffer-file-name
                                     (locate-dominating-file buffer-file-name
                                                             ".formatter.exs"))))
        (let ((default-directory mix-project-root))
          (apply original-fun args))
      (apply original-fun args)))
  ; adds an advice to the generated function +elxir-format-region that sets the proper root dir
  ; mix format needs to be run from the root directory otherwise it wont use the formatter configuration
  (advice-add '+elixir-format-region :around #'+set-default-directory-to-mix-project-root)
  ; Adds a hook to the major-mode that will add the generated function +elixir-format-on-save-mode
  ; So, every time we save an elixir file it will try to find a .formatter.exs and then run mix format from
  ; that file's directory
  (add-hook 'elixir-mode-hook #'+elixir-format-on-save-mode))
; NECESSARY LSP bits vvvv
(use-package lsp-mode
      :commands lsp
      :ensure t
      :diminish lsp-mode
      :hook
      (elixir-mode . lsp)
      :init
      (add-to-list 'exec-path "~/workspace/reference/elixir/elixir-ls/release"))
#+end_src
** Fennel (disabled)
[[https://fennel-lang.org/][Fennel]] "…is a programming language that brings together the simplicity, speed, and reach of Lua with the flexibility of a lisp syntax and macro system."

I keep thinking it'd be really cool to integrate this into some of my personal projects, but I've never done it. That's why this code isn't being "tangled" into my config.

#+begin_src elisp
;;------------- FENNEL
(autoload 'fennel-mode "/path/to/fennel-mode/fennel-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode))
#+end_src
** HTML
I know I'm a web dev, but I really wish I didn't have to touch HTML. Multi-web-mode works but it's janky AF and i don't like it. I'm constantly tempted to turn it off but i /like/ having JavaScript syntax highlighting when it's imbedded in an HTML file.

If you work in any atypical file formats that should be treated as if they were HTML (like Ruby's ERB files) you should add its file extension(s) to ~mweb-filename-extensions~ and the ~auto-mode-alist~ list which isn't web-mode specific. See its use in the Lua section below.

Also of note is ~mweb-tags~ which teaches it how to find the CSS or JavaScript section of a page. It could, in theory, be taught to recognize other things.

#+begin_src elisp :tangle config.el
;;------------- HTML
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.eex\\'" . web-mode))
; vvv--- live eex
(add-to-list 'auto-mode-alist '("\\.leex\\'" . web-mode))

(defun my-web-mode-hook ()
  "Hooks for Web mode."
  (setq web-mode-markup-indent-offset 2)
)
(add-hook 'web-mode-hook  'my-web-mode-hook)

; because i want HTML & Javascript highlighting in the same file
(require 'multi-web-mode)
(setq mweb-default-major-mode 'html-mode)
(setq mweb-tags
  '((php-mode "<\\?php\\|<\\? \\|<\\?=" "\\?>")
    (js-mode  "<script[^>]*>" "</script>")
    (css-mode "<style[^>]*>" "</style>")))
(setq mweb-filename-extensions '("php" "htm" "html" "ctp" "phtml" "php4" "php5" "erb"))
(multi-web-global-mode 1)
#+end_src

** Lua
…is another language I touch from time to time.

#+begin_src elisp :tangle config.el
;;------------- LUA
(autoload 'lua-mode "lua-mode" "Lua editing mode." t)
(add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
(add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
#+end_src
** Racket
The only thing I'm doing here is setting up auto-formatting on save.

#+begin_src elisp :tangle config.el
;;------------- RACKET
(defun raco-fmt ()
  "format with raco fmt"
  (when (eq major-mode 'racket-mode)
    (shell-command-to-string (format "raco fmt -i --width 80 %s" buffer-file-name))))

(add-hook 'after-save-hook #'raco-fmt)
#+end_src
** Raku
See [[https://github.com/Raku/raku-mode][the raku-mode repo]] for details. [[https://raku.org/][Raku]] is the result of a bunch of Perl geeks thinking really hard about what a cool new language would look like.

#+begin_src elisp :tangle config.el
;;------------- Raku
(define-auto-insert
	'("\\.rakumod\\'" . "Raku module skeleton")
	'raku-module-skeleton)
(define-auto-insert
	'("\\.raku\\'" . "Raku script skeleton")
	'raku-script-skeleton)
#+end_src
** Ruby
We're going to disable the rubocop & reek flycheck checkers. Especially rubocop because it /sucks/ and breaks half the time.

#+BEGIN_SRC elisp :tangle config.el
;;------------- RUBY
(after! 'ruby-mode
  (require 'ruby-tools))
(setq-default flycheck-disabled-checkers '(ruby-rubocop ruby-reek))
#+END_SRC
** YAML
Oddly, emacs doesn't seem to know that =.yml= is a common file extension for yaml.

#+begin_src elisp :tangle config.el
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+end_src

** Treesitter
Treesitter is a tool for parsing languages which was integrated into Emacs in version 29. You can learn more about getting started with it on [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][this Mastering Emacs blog post]].

This code tells treesitter where to find language files, but it does /not/ install them. You need to run ~(treesit-install-language-grammar "grammar_name")~ where "grammar_name" is the name of one of the entries in its language source list.

#+begin_src elisp :tangle config.el
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
#+end_src
* App Specific things
** Git
Tim Pope - again, Patron Saint of Vimmers - created a wonderful plugin called [[https://github.com/tpope/vim-fugitive][vim-fugitive]] that did a bunch of cool things with git.

The one that I used regularly was it's integration of [[https://git-scm.com/docs/git-blame][git blame]] which I find immensely helpful when working on a legacy codebase. It's the best way to go from being confused about a bit of code that you're looking at, to talking to the person who is most likely to be able to help you understand. My [[https://github.com/masukomi/masuconfigs/blob/master/bin/git-scripts/git-who-plain][git-who-plain]] bash script is a different approach to the same idea.

[[https://magit.vc/][Magit]]'s default representation of blame info does /not/ work for my 🧠. I hate it so much. Fortunately, I was able to tweak it into a close resemblance to vim-fugitive's output. Here's a link to [[https://github.com/magit/magit/blob/9b48dd7e3618ac3736f66ef964ae5e1fedd54f98/lisp/magit-blame.el#L39][the docs for configuring magit-blame-styles]].

#+begin_src elisp :tangle config.el
(setq magit-blame-styles
           '((margin
              (margin-width . 32)
              (margin-format . ("%C %a %f"))
              (margin-face . magit-blame-margin)
              (margin-body-face . magit-blame-dimmed)
              (show-message . t))))
#+end_src
** Diffs

Emacs, unsurprisingly, has a built in diffing tool. It's called ediff. Here are some helpful configs for making the experience of using it a little nicer. They were found [[https://pragmaticemacs.wordpress.com/2015/06/13/visualise-and-copy-differences-between-files/][on this blog post]] by Joe Rabinoff.

Full disclaimer, I set this up, but I never use ediff because [[https://kaleidoscope.app/][Kaleidoscope]] is a brilliant app with devs who just keep making it better.

#+begin_src elisp :tangle config.el
; ediff stuff
(require 'ediff)
;; don't start another frame
;; this is done by default in preluse
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
;; put windows side by side
(setq ediff-split-window-function (quote split-window-horizontally))
;;revert windows on exit - needs winner mode
(winner-mode)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+end_src

** GitHub Copilot
I'm really torn about [[https://github.com/features/copilot][GitHub Copilot]]. It drives me kinda buggy in languages I'm comfortable with, but it's helpful when tweaking files in languages I'm /not/ comfortable with. It's also pretty decent about generating boring code that needs to be written but doesn't require much thought. Well, except for the bits that look totally reasonable but are actually errors and you don't notice until you run your tests. You do have tests right?

Plus the company has drunk ALL the AI kool-aid and actually went so far as to imply that Copilot would be a good tool to help avoid developer burnout. Instead of, you know, treating them like humans who actually need time away from work to recover and enjoy their life & people outside of work.

Anyway. Copilot. Made by a company run by capitalist dicks who want to use technology instead of just being decent human beings.

The most important bit here is mapping ~copilot-accept-completion~ to a key-combo instead of the right arrow or return. Those paths just lead to frustration.

#+begin_src elisp :tangle config.el
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (
         ;; :map copilot-completion-map
         ;; ("<right>" . 'copilot-accept-completion)
         ("C-f" . 'copilot-accept-completion)
         ("M-<right>" . 'copilot-accept-completion-by-word)
         ("M-f" . 'copilot-accept-completion-by-word)
         ("C-e" . 'copilot-accept-completion-by-line)
         ("<end>" . 'copilot-accept-completion-by-line)
         ("M-n" . 'copilot-next-completion)
         ("M-p" . 'copilot-previous-completion)))
#+end_src

It is "strongly recommended" that you enable "childframe" option in "company module" to prevent overlay conflict. I don't know what that means and the instruction of calling ~(company +childframe)~ doesn't work because "company" is a "void" function. So, fuck it.

Copilot detects the language to use based on the current major-mode's name. It takes it and strips the ~-mode~ part. Sometimes that doesn't work well though, and it gives you crappy suggestions. To compensate you can give it a mapping to work with.

For example, if you use [[https://github.com/zenspider/enhanced-ruby-mode][enhanced-ruby-mode]] instead of the built-in ruby-mode you'd want to add this. I don't, so this bit isn't currently tangled.

#+begin_src elisp
(add-to-list 'copilot-major-mode-alist '("enh-ruby" . "ruby"))
#+end_src


* Doom's Helpful Instructions
Henrik & friends left us many useful instructions, which I'm keeping here, because I don't know what I'm doing.

First we have instructions about fonts & such.

#+begin_src elisp
;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-unicode-font' -- for unicode glyphs
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
;;(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;; (setq doom-theme 'doom-one)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

Next we have tips about loading packages.

#+begin_src elisp
;; Whenever you reconfigure a package, make sure to wrap your config in an
;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
;;
;;   (after! PACKAGE
;;     (setq x y))
;;
;; The exceptions to this rule:
;;
;;   - Setting file/directory variables (like `org-directory')
;;   - Setting variables which explicitly tell you to set them before their
;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
;;   - Setting doom variables (which start with 'doom-' or '+').
;;
;; Here are some additional functions/macros that will help you configure Doom.
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
;; etc).
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

* I wish I could…



** rg integration
I wish I could figure out how to get [[https://rgel.readthedocs.io/en/2.2.1/][rg.el]] (docs link) lazily loaded & working correctly. This is the Emacs package that integrates [[https://github.com/BurntSushi/ripgrep][ripgrep]].


#+BEGIN_SRC elisp
(require 'rg)
(rg-enable-default-bindings)
(global-set-key (kbd "C-c s") #'rg-menu)
(with-eval-after-load 'rg
  ;; Your settings goes here.
)
#+END_SRC

* Junk Drawer
I've tried and abandoned many things, in my attempt to make emacs work the way I want. What follows is the leftover detritus of those attempts. Things I've decided were probably worth keeping "in case I need them someday" but have subsequently completely forgotten everything about.

** ob-raku
#+begin_src elisp
(let ((ob-raku-file "~/workspace/ob-raku/ob-raku.el"))
 (when (file-exists-p ob-raku-file)
   (load-file ob-raku-file)))
#+end_src

** a custom tab character insertion
I made this function to insert a tab character. Why did I make this function. I never use this function.

#+BEGIN_SRC elisp
(defun masu-insert-tab-char ()
  "Insert a tab char. (ASCII 9, \t)"
  (interactive)
  (insert "\t"))
#+END_SRC

** Grammar Checking
[[https://github.com/abingham/flycheck-vale][flycheck-vale]] provides flycheck integration for [[https://github.com/ValeLint/vale][vale]]. Vale is a command-line tool that brings code-like linting to prose.

⚠ if the word its complaining about is the first word in a line it'll bork the indentation (visually only), which is really annoying. Especially if you don't want to change what it's complaining about.

I've disabled it because I wasn't deriving enough value from it and the indentation fuck-ups when I started a line with something like ~NOTE:~ were really annoying.

#+begin_src elisp
(require 'flycheck-vale)
(flycheck-define-checker vale
  "A checker for prose"
  :command ("vale" "--output" "line"
            source)
  :standard-input nil
  :error-patterns
  ((error line-start (file-name) ":" line ":" column ":" (id (one-or-more (not (any ":")))) ":" (message) line-end))
  :modes (markdown-mode org-mode text-mode)
  )
(add-to-list 'flycheck-checkers 'vale 'append)
(flycheck-vale-setup)
#+end_src
