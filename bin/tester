#!/usr/bin/env ruby

require 'json'
require 'open3'


USAGE=<<~EOL
tester is a convenience tool to make life easier when dealing with RSpec.

Output is limited to actionable details about failing tests and
just enough to get you to the right place to fix them.

tester also has a number of options for making it trivial to rerun
failing tests without needing to specify paths and line numbers.


USAGE:

tester [-h | --help | help]
  display these usage instructions

tester
  shows you numbered list of last test failures (if any)

tester all
  run _all_ rspect tests

tester last_file
  finds the last file that had a problem
  and runs all the tests in it.

tester <n>
  re-run a specific failure from the last test
  as identified by its number

test <n> +/-<x>
  re-run a specific failure from the last test
  as identified by its number
  BUT offset the line number of the test +/- x
  (useful if you've added or removed lines above it)

  Ex. tester 5 +2
  runs example number 5 but specifes a line number 2 greater
  than the initial failure reported.

tester <path_to/file_spec.rb>
  run a specific spec and captures failures (if any)
  you can run it with the optional line number syntax too
  E.g. tester path_to/file_spec.rb
    or tester path_to/file_spec.rb:32

tester kill <number>
  removes the test with the specified number from the
  list of past failures

tester kill <number>-<number>
  removes the tests with numbers within the specified
  range of past failure numbers (inclusive).

tester rerun
  runs all the past failures
  functionally identical to calling with just the
  number for each of the known failures.

tester file <number>
  outputs the file path from the test with that number

tester files
  outputs a list of all the files+line numbers of failing tests
EOL


PAST_RUN_FILENAME=".specs.json"
INPUT = ARGV.size > 0 ? ARGV[0].strip : nil
past_run_data = {}
# looks like
# {
#   failures: [
#     {
#       message: "",
#       details: "",
#       file: "",
#       line_number: 123
#       expected: ""
#       got: "",
#       diff: ""
#     }
#   ]
# }

def display_failures(failures)
  failures.each_with_index do | failure, idx |
    display_failure(failure, idx)
  end
end

def display_failure(failure, index)
    puts "\n\e[31m#{index + 1}: #{failure["message"]}\e[0m\n"
    puts printable_file_and_line_num(failure)
    puts failure["details"] if failure.has_key? "details"

    puts "\t\t\e[32mexpected: #{failure["expected"]}\e[0m" if failure.has_key? "expected"
    puts "\t\t\e[91mgot     : #{failure["got"]}\e[0m" if failure.has_key? "got"

    puts "\n\t\tDiff:\n#{failure["diff"].join("\n\t\t")}" if failure.has_key? "diff"

end
def printable_file_and_line_num(failure)
  "\t\e[100;37m#{failure["file"]}\e[0m:\e[100;33m#{failure["line_number"]}\e[0m"
end

def process_rspec_output(output)
  new_run_data = {"failures" => []}
  output_lines = output.split("\n")
  in_failure = false
  in_diff = false
  current_failure = {}
  output_lines.each_with_index do | line, idx |
    if not in_failure
      match_data =  /^  \d+\)\s+(.*)/.match(line)
      if match_data
        # starting a new failure
        in_failure = true
        new_run_data['failures'] << current_failure unless current_failure.empty?
        current_failure = {}
        current_failure["message"] = match_data[1]
      # else, random crap we don't care about
      end
    else
      # in a failure, and past the initial line
      details_match = /^\s+Failure\/Error:\s*(.*)/.match(line)

      expected_match = /^\s+expected:\s+(.*)/.match(line)

      # seriously RSpec? Why can't you be consistent?
      got_match = /^\s+(?:got|received):\s+(.*)/.match(line)

      trace_match = /^\s+#\s+(.*?\/(.*?\.rb)):(\d+):in /.match(line)

      diff_match = /^\s+Diff:\s*/.match(line)

      if details_match
        current_failure["details"] = details_match[1]
      elsif expected_match
        current_failure["expected"] = expected_match[1]
      elsif got_match
        current_failure["got"] = got_match[1]
      elsif trace_match
        in_diff = false
        current_failure["file"] = trace_match[2]
        current_failure["full_file_path"] = trace_match[1]
        current_failure["line_number"] = trace_match[3]
        in_failure = false
      elsif diff_match && ! in_diff
        in_diff = true
        current_failure["diff"] = []
          # ends when we get to the trace_match
          # don't want the first line since it's just "Diff:"
      elsif in_diff
        current_failure["diff"] << line.lstrip
      elsif current_failure.has_key? "details"
        #we're somewhere between the Failure/Error line
        #and the stack trace
        current_failure["details"] += "\n#{line}"
      end

    end
  end
  new_run_data['failures'] << current_failure unless current_failure.empty?
  new_run_data
end

def run_this(spec, update_file, retries = 0)
  run_line ="bundle exec rspec #{spec}"
  output, standard_error, status = Open3.capture3( "#{run_line}")
  if status.exitstatus != 0
    if output.match(/^LoadError:/) || output.match(/^NameError:/)
      puts "problems encountered: \n\t#{output.split("\n").first(10).join("\n\t")}\n..."
      # for whatever reason rspec sends SOME errors to standard out
      # not standard error
      exit status.exitstatus
    elsif standard_error.match(/Bundler::GemNotFound/m)
      puts "You need to bundle"
      puts "I'll do that for you."
      if retries == 0
        bundle_output, bundle_standard_error, bundle_status = Open3.capture3( "bundle install")
        if bundle_status.exitstatus == 0
          run_this(spec, update_file, 1)
        else
          puts "Nope. I failed to bundle for you."
          puts bundle_status_error
          exit bundle_status.exitstatus
        end
      else
        exit status.exitstatus
      end
    end
  end
  new_run_data = process_rspec_output(output)
  update_record(new_run_data) if update_file
  new_run_data
end

def update_record(new_run_data)
  File.write(PAST_RUN_FILENAME, new_run_data.to_json)
end

def output_run_results(run_data)
  if run_data['failures'].size > 0
    display_failures(run_data['failures'])
  else
    puts "no failures"
  end
end

def display_last_run(past_run_data)
  if past_run_data.fetch('failures', {}).size > 0
    puts "Displaying failures"
    display_failures(past_run_data['failures'])
  else
    puts "No past run data. Please run a spec through me."
  end
end

def display_files(past_run_data)
  last_output = nil
  items_displayed = 0
  past_run_data["failures"].each_with_index do | failure, idx |
    this_output = printable_file_and_line_num(failure)
    if this_output != last_output
      puts "#{idx + 1}: #{this_output}"
      items_displayed += 1
      last_output = this_output
    end
  end
  if items_displayed < past_run_data["failures"].size
    puts "\n\n\tNOTE: some duplicate results excluded"
    puts "\tThis just means some common problem is causing multiple"
    puts "\ttests to fail in the same way."
    puts "\n\trun `tester` with no args to see the full list."
  end
end

def rerun_run_number(num, line_mod, past_run_data)
  idx = num - 1
  if past_run_data["failures"].size > 0 && past_run_data["failures"][idx]
    line_num = past_run_data["failures"][idx]["line_number"].to_i
    line_num += line_mod
    spec = past_run_data["failures"][idx]["full_file_path"]
    spec += ":#{line_num}" if line_num
    puts "Running: #{spec}\n#{past_run_data["failures"][idx]["message"]}\n\n----------------------------\n"
    output_run_results(run_this(spec, false))
  else
    STDERR.puts("I don't seem to have data on run #{idx + 1}")
  end
end

# -------------------------

past_run_data = {"failures" => []}
if File.exist? PAST_RUN_FILENAME
  begin
  past_run_data = JSON.parse(File.read(PAST_RUN_FILENAME))
  rescue StandardError => e
    STDERR.puts("problem parsing #{PAST_RUN_FILENAME}: #{e.message}")
  end
end

if INPUT.nil?
  display_last_run(past_run_data)
elsif /.*_spec.rb(:\d+)?$/.match(INPUT) || INPUT=="all" || INPUT=="last_file"
  if INPUT != "all" && INPUT != "last_file"
    # must be a spec file
    updated_run_data = run_this(INPUT, true)
  elsif INPUT == "last_file"
    if past_run_data["failures"].empty?
      puts "No file data from last run"
      exit 64 # EX_USAGE
    end
    last_file = past_run_data["failures"]
      .map{|f| f["file"]}
      .select{|f| f.end_with?("_spec.rb")}
      .last
    puts "Running #{last_file}...\n"
    updated_run_data = run_this(last_file, true)
  elsif INPUT == "all"
    puts "Running ALL specs...\n"
    updated_run_data = run_this("", true)
  end
  output_run_results(updated_run_data)
elsif /^\d+$/.match(INPUT)
  line_mod = ARGV.size > 1 ? ARGV[1].to_i : 0
  rerun_run_number(INPUT.to_i, line_mod, past_run_data)
elsif INPUT == "rerun"
 (1..past_run_data["failures"].size).each do | num |
  rerun_run_number(num, 0, past_run_data)
 end
elsif INPUT == "kill" &&  /^\d+(-\d+)?$/.match(ARGV[1].to_s)
  indexes = Array(ARGV[1].to_i - 1)
  if /^\d+-\d+?$/.match(ARGV[1])
    x, y = ARGV[1].split('-').map(&:to_i)
    # If we work from highest to lowest we can
    # avoid complications resulting
    # from shortening an array while iterating over it

    if x < y
      indexes = ((x - 1)..(y - 1)).to_a.reverse
    elsif x == y
      indexes = [x]
    else
      indexes = ((x - 1)..(y - 1)).to_a
    end

  end

  indexes.each do |idx|
    puts "killing #{idx}: #{past_run_data["failures"][idx]["message"]}"
    # display_failure(past_run_data["failures"][idx], idx)
    past_run_data["failures"].slice!(idx)
  end
  puts "-------------------------------------------------\n"
  puts "-------------------------------------------------\n"
  update_record(past_run_data)
  display_last_run(past_run_data)
elsif INPUT == "file" &&  /^\d+$/.match(ARGV[1].to_s)
  idx = ARGV[1].to_i - 1
  if past_run_data.size > idx
    puts past_run_data["failures"][idx]["file"]
  else
    exit 75 # EX_TEMPFAIL (user input)
  end
elsif INPUT == "files"
  display_files(past_run_data)
elsif /^-{0,2}h(?:elp)?$/.match(INPUT)
  puts USAGE
end

