#!/usr/bin/env ruby

require 'json'
require 'open3'

# in case you use byebug or binding.pry
require 'pty'
require 'io/wait'
require 'stringio'
require 'expect'



# KNOWN ISSUES
# - hangs waiting for input if you have a binding.pry / byebug in your code
# - "tester rerun" doesn't show the output with the same numbers you'd see
#   if you ran "tester" with no args.

USAGE=<<~EOL
tester is a convenience tool to make life easier when dealing with RSpec.

Output is limited to actionable details about failing tests and
just enough to get you to the right place to fix them.

tester also has a number of options for making it trivial to rerun
failing tests without needing to specify paths and line numbers.


USAGE:

tester [-h | --help | help]
  display these usage instructions

tester
  shows you numbered list of last test failures (if any)

tester all
  run _all_ rspect tests

tester last_file
  finds the last file that had a problem
  and runs all the tests in it.

tester <n>
  re-run a specific failure from the last test
  as identified by its number

test <n> +/-<x>
  re-run a specific failure from the last test
  as identified by its number
  BUT offset the line number of the test +/- x
  (useful if you've added or removed lines above it)

  Ex. tester 5 +2
  runs example number 5 but specifes a line number 2 greater
  than the initial failure reported.

tester <path_to/file_spec.rb>
  run a specific spec and captures failures (if any)
  you can run it with the optional line number syntax too
  E.g. tester path_to/file_spec.rb
    or tester path_to/file_spec.rb:32

tester kill <number>
  removes the test with the specified number from the
  list of past failures

tester kill <number>-<number>
  removes the tests with numbers within the specified
  range of past failure numbers (inclusive).

tester rerun
  runs all the past failures
  functionally identical to calling with just the
  number for each of the known failures.

tester file <number>
  outputs the file path from the test with that number

tester files
  outputs a list of all the files+line numbers of failing tests
EOL
USAGE.freeze


# The regex to match ANSI codes
# from https://github.com/piotrmurach/strings-ansi
ANSI_MATCHER = %r{
  (?>\033(
    \[[\[?>!]?\d*(;\d+)*[ ]?[a-zA-Z~@$^\]_\{\\] # graphics
    |
    \#?\d # cursor modes
    |
    [)(%+\-*/. ](\d|[a-zA-Z@=%]|) # character sets
    |
    O[p-xA-Z] # special keys
    |
    [a-zA-Z=><~\}|] # cursor movement
    |
    \]8;[^;]*;.*?(\033\\|\07) # hyperlink
  ))
}x.freeze


NO_FAILURES_TEXT="✅ No failures."

PAST_RUN_FILENAME=".specs.json"
INPUT = ARGV.size > 0 ? ARGV[0].strip : nil
past_run_data = {}
# looks like
# {
#   failures: [
#     {
#       message: "",
#       details: "",
#       file: "",
#       line_number: 123
#       expected: ""
#       got: "",
#       diff: ""
#     }
#   ]
# }

################
# terminal interactivity stuff
# in case you use binding.pry or byebug
# type things
def process_running?(pid)
  Process.getpgid(pid)
  true # or boom
rescue
  false
end

def buffer_last_line(buffer)
  line = buffer.string.split("\n").last
  return nil unless line
  line.gsub(ANSI_MATCHER, "")
end

def definite_debugger_line(line)
  return false unless line
  # puts "line.inspect: '#{line.inspect}'"
  !! line.match(/^\(byebug\) $|^\[\d+\] pry\(.*?\)> $/)
end
def potential_debugger_pause(line)
  !! line.match(/^\s*\d+:\s+/)
end

def wait_for_read(reader, pid, last_line, counter = 0)
  # counter is a count of times through this with
  # potential debugger pause lines
  running = process_running?(pid)
  if running && ! reader.ready?
    putc "."
    return :debugger if definite_debugger_line(last_line)
    if last_line && potential_debugger_pause(last_line)
      counter += 1
      return :debugger if counter > 4
    # else
    #   putc last_line.nil? ? "-" : "x"
    #   puts "last_line: #{last_line}" unless last_line.nil?
    end
    sleep 0.2
    wait_for_read(reader, pid, last_line, counter)
  elsif running
    :running
  else
    :ready
  end
end

def read_into_buffer(reader, buffer)
  loop do
    break unless reader.ready?
    char = reader.read(1)
    break if char.nil?
    buffer.putc(char)
  end
  buffer
end

################



def display_failures(failures)
  failures.each_with_index do | failure, idx |
    display_failure(failure, idx)
  end
end

def display_failure(failure, index)
    puts "\n\e[31m#{index + 1}: #{failure["message"]}\e[0m\n"
    puts printable_file_and_line_num(failure)
    puts failure["details"] if failure.has_key? "details"

    puts "\t\t\e[32mexpected: #{failure["expected"]}\e[0m" if failure.has_key? "expected"
    puts "\t\t\e[91mgot     : #{failure["got"]}\e[0m" if failure.has_key? "got"

    puts "\n\t\tDiff:\n#{failure["diff"].join("\n\t\t")}" if failure.has_key? "diff"

end
def printable_file_and_line_num(failure)
  if failure["spec_file"]
    line = "#{ failure["file"].nil? ? "\t" : ""}\e[100;37m#{failure["spec_file_full_path"]}\e[0m:\e[100;33m#{failure["spec_file_line_number"]}\e[0m"

    if failure["file"]
      line = "\tFAILED SPEC: " + line
      line += "\n\tERROR HERE : \e[100;37m#{failure["file_full_path"]}\e[0m:\e[100;33m#{failure["line_number"]}\e[0m"
    end
    line
  else
    "\t\e[100;37m#{failure["file"]}\e[0m:\e[100;33m#{failure["line_number"]}\e[0m"
  end
end

def process_rspec_output(output)
  new_run_data = {"failures" => []}
  output_lines = output.split("\n")
  in_failure = false
  in_diff = false
  current_failure = {}
  output_lines.each_with_index do | line, idx |
    if not in_failure
      match_data =  /^  \d+\)\s+(.*)/.match(line)
      if match_data
        # starting a new failure
        in_failure = true
        unless current_failure.empty?
          new_run_data['failures'] << current_failure
          display_failure(current_failure, new_run_data['failures'].length - 1)
        end
        current_failure = {}
        current_failure["message"] = match_data[1]
      # else, random crap we don't care about
      end
    else
      # in a failure, and past the initial line
      details_match = /^\s+Failure\/Error:\s*(.*)/.match(line)

      expected_match = /^\s+expected:\s+(.*)/.match(line)

      # seriously RSpec? Why can't you be consistent?
      got_match = /^\s+(?:got|received):\s+(.*)/.match(line)

      trace_match = /^\s+#\s+(.*?\/(.*?\.rb)):(\d+):in /.match(line)
      spec_match = /^\s+#\s+((?:\.\/)?spec\/.*?\/(.*?\.rb)):(\d+):in /.match(line)
      # ^^^ https://regexper.com/#%5E%5Cs%2B%23%5Cs%2B%28%28%3F%3A%5C.%5C%2F%29%3Fspec%5C%2F.*%3F%5C%2F%28.*%3F%5C.rb%29%29%3A%28%5Cd%2B%29%3Ain%20

      diff_match = /^\s+Diff:\s*/.match(line)

      if details_match
        current_failure["details"] = details_match[1]
      elsif expected_match
        current_failure["expected"] = expected_match[1]
      elsif got_match
        current_failure["got"] = got_match[1]
      elsif spec_match && current_failure["spec_file"].nil?
        current_failure["spec_file"] = spec_match[2]
        current_failure["spec_file_full_path"] = spec_match[1]
        current_failure["spec_file_line_number"] = spec_match[3]
        in_failure = false
      elsif trace_match and current_failure["file"].nil?
        in_diff = false
        current_failure["file"] = trace_match[2]
        current_failure["file_full_path"] = trace_match[1]
        current_failure["line_number"] = trace_match[3]
        in_failure = false unless current_failure["spec_file"].nil?
      elsif diff_match && ! in_diff
        in_diff = true
        current_failure["diff"] = []
          # ends when we get to the trace_match
          # don't want the first line since it's just "Diff:"
      elsif in_diff
        current_failure["diff"] << line.lstrip
      elsif current_failure.has_key? "details"
        #we're somewhere between the Failure/Error line
        #and the stack trace
        current_failure["details"] += "\n#{line}"
      end

    end
  end
  unless current_failure.empty?
    new_run_data['failures'] << current_failure
    display_failure(current_failure, new_run_data['failures'].length - 1)
  end
  new_run_data
end


def interactive_run_handler(run_line, output_buffer)
  PTY.spawn(run_line) do |reader, writer, pid|
    if process_running?(pid)
      while process_running?(pid)
        wait_response = wait_for_read(reader, pid, buffer_last_line(output_buffer))
        if wait_response != :running # ready or debugger
          read_into_buffer(reader, output_buffer)
          # break unless process_running?(pid)
          if ! process_running?(pid)
            break
          end
          if wait_response == :debugger || reader.expect(/^\(byebug\) /, 0.2) #wait 0.2 sec for a match
            puts "\n" + output_buffer.string.split("\n").reverse[0..10].reverse.join("\n")
            user_input = STDIN.gets.chomp
            writer.puts user_input
            sleep 0.2 # give it a moment to exit if it wants to
          else
          #   # did not see ">" within 2 seconds
          #   puts "foo.fail"
          end
          # break unless process_running?(pid)
        end

         read_into_buffer(reader, output_buffer)
      end
    else
      read_into_buffer(reader, output_buffer)
    end
  end
  output_buffer
end

def run_this(spec, update_file, retries = 0)
  run_line ="bundle exec rspec #{spec} 2>&1"
  # Redirecting STDERR to STDOUT because rspec is...
  # They've made "interesting" choices about what goes where
  output_buffer = interactive_run_handler(run_line, StringIO.new(""))


  # Getting the exit code from PTY.spawn requires calling
  # Process.wait(pid)
  # but that just waits until it exits which will block,
  # so... just gonna have to do without that unless
  # you, my brilliant reader, know a workaround.

  output = output_buffer.string


  if output.match(/^[A-Z]+[a-z]+\w+Error:/)
    puts "⚠️ Problems encountered: \n\t#{output.split("\n").first(10).join("\n\t")}\n..."
    # for whatever reason rspec sends SOME errors to standard out
    # not standard error
    exit 1
  elsif output.match(/(Bundler::GemNotFound|Bundler could not find compatible versions)/m)
    if output.match(/could not find compatible versions/m)
      puts "Bundler issue you'll have to address..."
      puts standard_error.split("\n")[0..20].join("\n")+"\n..."
      exit 1
    end
    puts "You need to bundle"
    puts "I'll do that for you."
    if retries == 0
      bundle_output, bundle_standard_error, bundle_status = Open3.capture3( "bundle install")
      if bundle_status.exitstatus == 0
        run_this(spec, update_file, 1)
      else
        puts "Nope. I failed to bundle for you."
        puts bundle_standard_error
        exit bundle_status.exitstatus
      end
    else
      exit 2
    end
  end
  new_run_data = process_rspec_output(output)
  update_record(new_run_data) if update_file
  new_run_data
end

def update_record(new_run_data)
  File.write(PAST_RUN_FILENAME, new_run_data.to_json)
end

def output_run_results(run_data)
  if run_data['failures'].size > 0
    display_failures(run_data['failures'])
  else
    puts NO_FAILURES_TEXT
  end
end

def display_last_run(past_run_data)
  failures_count = past_run_data.fetch('failures', {})
  if failures_count.size > 0
    puts "Displaying failures (#{failures_count})"
    display_failures(past_run_data['failures'])
  else
    puts "No past run data. Please run a spec through me."
  end
end

def display_files(past_run_data)
  last_output = nil
  items_displayed = 0
  past_run_data["failures"].each_with_index do | failure, idx |
    this_output = printable_file_and_line_num(failure)
    if this_output != last_output
      puts "#{idx + 1}: #{this_output}"
      items_displayed += 1
      last_output = this_output
    end
  end
  if items_displayed < past_run_data["failures"].size
    puts "\n\n\tNOTE: some duplicate results excluded"
    puts "\tThis just means some common problem is causing multiple"
    puts "\ttests to fail in the same way."
    puts "\n\trun `tester` with no args to see the full list."
  end
end

def rerun_run_number(num, line_mod, past_run_data)
  idx = num - 1
  if past_run_data["failures"].size > 0 && past_run_data["failures"][idx]
    line_num = past_run_data["failures"][idx]["line_number"].to_i
    line_num += line_mod
    if past_run_data["failures"][idx]["spec_file"].nil?
      spec = past_run_data["failures"][idx]["file_full_path"]
      spec += ":#{line_num}" if line_num
    else
      line_num = past_run_data["failures"][idx]["spec_file_line_number"].to_i
      line_num += line_mod

      spec = past_run_data["failures"][idx]["spec_file_full_path"]
      spec += ":#{line_num}" if line_num
    end
    puts "Running: #{spec}\n#{past_run_data["failures"][idx]["message"]}\n\n----------------------------\n"
    # output_run_results(run_this(spec, false))
    run_data = run_this(spec, false)
    puts NO_FAILURES_TEXT if run_data['failures'].size == 0
  else
    STDERR.puts("I don't seem to have data on run #{idx + 1}")
  end
end

# -------------------------

past_run_data = {"failures" => []}
if File.exist? PAST_RUN_FILENAME
  begin
  past_run_data = JSON.parse(File.read(PAST_RUN_FILENAME))
  rescue StandardError => e
    STDERR.puts("problem parsing #{PAST_RUN_FILENAME}: #{e.message}")
  end
end

if INPUT.nil?
  display_last_run(past_run_data)
elsif /.*_spec.rb(:\d+)?$/.match(INPUT) \
  || INPUT=="all" \
  || INPUT=="last_file" \
  || /\S+\/$/.match(INPUT) # ends with a slash, prolly a directory
  if INPUT != "all" && INPUT != "last_file"
    puts "Running specs in #{INPUT}\n"
    # must be a spec file
    updated_run_data = run_this(INPUT, true)
  elsif INPUT == "last_file"
    if past_run_data["failures"].empty?
      puts "No file data from last run"
      exit 64 # EX_USAGE
    end
    last_file = past_run_data["failures"]
      .map{|f| f["spec_file"] || f["file"]}
      .select{|f| f.end_with?("_spec.rb")}
      .last
    puts "Running #{last_file}...\n"
    updated_run_data = run_this(last_file, true)
  elsif INPUT == "all"
    puts "Running ALL specs...\n"
    updated_run_data = run_this("", true)
  end
  # output_run_results(updated_run_data)
  puts NO_FAILURES_TEXT if updated_run_data['failures'].size == 0
elsif /^\d+$/.match(INPUT)
  line_mod = ARGV.size > 1 ? ARGV[1].to_i : 0
  rerun_run_number(INPUT.to_i, line_mod, past_run_data)
elsif INPUT == "rerun"
 if past_run_data["failures"].size == 0
   puts "No past failures found to rerun."
   exit 0
 end
 run_range = (1..past_run_data["failures"].size)
 run_range.each do | num |
  rerun_run_number(num, 0, past_run_data)
 end
elsif INPUT == "kill" &&  /^\d+(-\d+)?$/.match(ARGV[1].to_s)
  indexes = Array(ARGV[1].to_i - 1)
  if /^\d+-\d+?$/.match(ARGV[1])
    x, y = ARGV[1].split('-').map(&:to_i)
    # If we work from highest to lowest we can
    # avoid complications resulting
    # from shortening an array while iterating over it

    if x < y
      indexes = ((x - 1)..(y - 1)).to_a.reverse
    elsif x == y
      indexes = [x]
    else
      indexes = ((x - 1)..(y - 1)).to_a
    end

  end

  indexes.each do |idx|
    puts "killing #{idx}: #{past_run_data["failures"][idx]["message"]}"
    # display_failure(past_run_data["failures"][idx], idx)
    past_run_data["failures"].slice!(idx)
  end
  puts "-------------------------------------------------\n"
  puts "-------------------------------------------------\n"
  update_record(past_run_data)
  display_last_run(past_run_data)
elsif INPUT == "file" &&  /^\d+$/.match(ARGV[1].to_s)
  idx = ARGV[1].to_i - 1
  if past_run_data.size > idx
    puts past_run_data["failures"][idx]["file"]
  else
    exit 75 # EX_TEMPFAIL (user input)
  end
elsif INPUT == "files"
  display_files(past_run_data)
elsif /^-{0,2}h(?:elp)?$/.match(INPUT)
  puts USAGE
end

