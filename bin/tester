#!/usr/bin/env ruby

# USAGE:
# tester
#   provide info about failures from last run
# tester all
#   run all rspect tests
# tester last_file
#   finds the last file that had a problem
#   and runs all the tests in it.
# tester <n>
#   re-run a specific failure from the last test
#   as identified by its number
# test <n> +/-<x>
#   re-run a specific failure from the last test
#   as identified by its number
#   BUT offset the line number of the test +/- x
#   (useful if you've added or removed lines above it)
#
#   Ex. tester 5 +2
#   runs example number 5 but specifes a line number 2 greater
#   than the initial failure reported.
#
# tester path_to/file_spec.rb
#   run a specific spec.
#   you can run it with the optional line number syntax too

# input options
# - no input
#   - shows you numbered list of last test failures (if any)
# - path
#   - runs test command against path provided
#   - captures failures (if any)
# - number
#   - loads list of last test failures
#   - finds matching number. runs that failing test.
# - kill number
#   - removes the test with the specified number from the
#     list of past failures
# - file number
#   - outputs the file path from the test with that number
# - files
#   - outputs a list of all the files+line numbers of failing tests
require 'json'
require 'open3'


PAST_RUN_FILENAME=".specs.json"
INPUT = ARGV.size > 0 ? ARGV[0].strip : nil
past_run_data = {}
# looks like
# {
#   failures: [
#     {
#       message: "",
#       details: "",
#       file: "",
#       line_number: 123
#       expected: ""
#       got: "",
#       diff: ""
#     }
#   ]
# }

def display_failures(failures)
  failures.each_with_index do | failure, idx |
    display_failure(failure, idx)
  end
end

def display_failure(failure, index)
    puts "\n#{index + 1}: #{failure["message"]}\n"
    puts printable_file_and_line_num(failure)
    puts failure["details"] if failure.has_key? "details"

    puts "\t\t\e[32mexpected: #{failure["expected"]}\e[0m" if failure.has_key? "expected"
    puts "\t\t\e[91mgot     : #{failure["got"]}\e[0m" if failure.has_key? "got"

    puts "\n\t\tDiff:\n#{failure["diff"].join("\n\t\t")}" if failure.has_key? "diff"

end
def printable_file_and_line_num(failure)
  "\t\e[100;37m#{failure["file"]}\e[0m:\e[100;33m#{failure["line_number"]}\e[0m"
end

def process_rspec_output(output)
  new_run_data = {"failures" => []}
  output_lines = output.split("\n")
  in_failure = false
  in_diff = false
  current_failure = {}
  output_lines.each_with_index do | line, idx |
    if not in_failure
      match_data =  /^  \d+\)\s+(.*)/.match(line)
      if match_data
        # starting a new failure
        in_failure = true
        new_run_data['failures'] << current_failure unless current_failure.empty?
        current_failure = {}
        current_failure["message"] = match_data[1]
      # else, random crap we don't care about
      end
    else
      # in a failure, and past the initial line
      details_match = /^\s+Failure\/Error:\s*(.*)/.match(line)

      expected_match = /^\s+expected:\s+(.*)/.match(line)

      got_match = /^\s+got:\s+(.*)/.match(line)

      trace_match = /^\s+#\s+(.*?\/(.*?\.rb)):(\d+):in /.match(line)

      diff_match = /^\s+Diff:\s*/.match(line)

      if details_match
        current_failure["details"] = details_match[1]
      elsif expected_match
        current_failure["expected"] = expected_match[1]
      elsif got_match
        current_failure["got"] = got_match[1]
      elsif trace_match
        in_diff = false
        current_failure["file"] = trace_match[2]
        current_failure["full_file_path"] = trace_match[1]
        current_failure["line_number"] = trace_match[3]
        in_failure = false
      elsif diff_match && ! in_diff
        in_diff = true
        current_failure["diff"] = []
          # ends when we get to the trace_match
          # don't want the first line since it's just "Diff:"
      elsif in_diff
        current_failure["diff"] << line.lstrip
      elsif current_failure.has_key? "details"
        #we're somewhere between the Failure/Error line
        #and the stack trace
        current_failure["details"] += "\n#{line}"
      end

    end
  end
  new_run_data['failures'] << current_failure unless current_failure.empty?
  new_run_data
end

def run_this(spec, update_file)
  run_line ="bundle exec rspec #{spec}"
  output, standard_error, status = Open3.capture3( "#{run_line}")
  if status.exitstatus != 0 && output.match(/^LoadError:/)
    puts "problems encountered: \n\t#{output.split("\n").first(10).join("\n\t")}\n..."
    # for whatever reason rspec sends errors to standard out
    # not standard error
    exit status.exitstatus
  end
  new_run_data = process_rspec_output(output)
  update_record(new_run_data) if update_file
  new_run_data
end

def update_record(new_run_data)
  File.write(PAST_RUN_FILENAME, new_run_data.to_json)
end

def output_run_results(run_data)
  if run_data['failures'].size > 0
    display_failures(run_data['failures'])
  else
    puts "no failures"
  end
end

def display_last_run(past_run_data)
  if past_run_data.fetch('failures', {}).size > 0
    puts "Displaying failures"
    display_failures(past_run_data['failures'])
  else
    puts "No past run data. Please run a spec through me."
  end
end

def display_files(past_run_data)
  last_output = nil
  items_displayed = 0
  past_run_data["failures"].each_with_index do | failure, idx |
    this_output = printable_file_and_line_num(failure)
    if this_output != last_output
      puts "#{idx + 1}: #{this_output}"
      items_displayed += 1
      last_output = this_output
    end
  end
  if items_displayed < past_run_data["failures"].size
    puts "\n\n\tNOTE: some duplicate results excluded"
    puts "\tThis just means some common problem is causing multiple"
    puts "\ttests to fail in the same way."
    puts "\n\trun `tester` with no args to see the full list."
  end
end

# -------------------------

past_run_data = {"failures" => []}
if File.exist? PAST_RUN_FILENAME
  begin
  past_run_data = JSON.parse(File.read(PAST_RUN_FILENAME))
  rescue StandardError => e
    STDERR.puts("problem parsing #{PAST_RUN_FILENAME}: #{e.message}")
  end
end

if INPUT.nil?
  display_last_run(past_run_data)
elsif /.*_spec.rb(:\d+)?$/.match(INPUT) || INPUT=="all" || INPUT=="last_file"
  if INPUT != "all" && INPUT != "last_file"
    # must be a spec file
    updated_run_data = run_this(INPUT, true)
  elsif INPUT == "last_file"
    if past_run_data["failures"].empty?
      puts "No file data from last run"
      exit 64 # EX_USAGE
    end
    last_file = past_run_data["failures"]
      .map{|f| f["file"]}
      .select{|f| f.end_with?("_spec.rb")}
      .last
    puts "Running #{last_file}...\n"
    updated_run_data = run_this(last_file, true)
  elsif INPUT == "all"
    puts "Running ALL specs...\n"
    updated_run_data = run_this("", true)
  end
  output_run_results(updated_run_data)
elsif /^\d+$/.match(INPUT)
  idx = INPUT.to_i - 1
  line_mod = ARGV.size > 1 ? ARGV[1].to_i : 0
  if past_run_data["failures"].size > 0 && past_run_data["failures"][idx]
    line_num = past_run_data["failures"][idx]["line_number"].to_i
    line_num += line_mod
    spec = past_run_data["failures"][idx]["full_file_path"]
    spec += ":#{line_num}" if line_num
    puts "Running: #{spec}\n#{past_run_data["failures"][idx]["message"]}\n\n----------------------------\n"
    output_run_results(run_this(spec, false))
  else
    STDERR.puts("I don't seem to have data on run #{idx + 1}")
  end
elsif INPUT == "kill" &&  /^\d+(-\d+)?$/.match(ARGV[1].to_s)
  indexes = Array(ARGV[1].to_i - 1)
  if /^\d+-\d+?$/.match(ARGV[1])
    x, y = ARGV[1].split('-').map(&:to_i)
    # If we work from highest to lowest we can
    # avoid complications resulting
    # from shortening an array while iterating over it

    if x < y
      indexes = ((x - 1)..(y - 1)).to_a.reverse
    elsif x == y
      indexes = [x]
    else
      indexes = ((x - 1)..(y - 1)).to_a
    end

  end

  indexes.each do |idx|
    puts "killing #{idx}: #{past_run_data["failures"][idx]["message"]}"
    # display_failure(past_run_data["failures"][idx], idx)
    past_run_data["failures"].slice!(idx)
  end
  puts "-------------------------------------------------\n"
  puts "-------------------------------------------------\n"
  update_record(past_run_data)
  display_last_run(past_run_data)
elsif INPUT == "file" &&  /^\d+$/.match(ARGV[1].to_s)
  idx = ARGV[1].to_i - 1
  if past_run_data.size > idx
    puts past_run_data["failures"][idx]["file"]
  else
    exit 75 # EX_TEMPFAIL (user input)
  end
elsif INPUT == "files"
  display_files(past_run_data)
end

