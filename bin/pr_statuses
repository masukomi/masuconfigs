#!/usr/bin/env ruby
require 'json'


GH_USERNAME = "YOUR GITHUB USERNAME"
# BASE is a root developement directory that you keep your directories
# under. For example: ~/workspace
BASE = "#{Dir.home}/root/dir/containing/projects".freeze
# directories directly under BASE that you wish to skip
IGNORABLE_DIRS = %w[dir names to be ignored].freeze
# string identifier of the check that you should ignore
# For example if you wanted to ignore
# ci/circleci: Build Error ...details here
# you'd add ci/circleci to this list
IGNORABLE_PR_CHECKS = %[].freeze
def error_and_die(message)
  STDERR.puts(message)
  STDERR.puts("Exiting.")

  exit 1
end
def output_approved_reviews(author, author_reviews)
  puts "\e[32mApproved by #{author}\e[0m"
  author_reviews.each do | ar |
    if ar["state"]=="APPROVED" && ar["body"] != ""
      puts ar["body"]
    end
  end
end

def output_unapproved_reviews(author, author_reviews)
  states = author_reviews.map{ |ar| ar["STATE"] }.uniq.compact
  return if states.size == 0 # sometime's there's a nil state
  puts "\e[34m#{author}: #{states.join(", ")} \e[0m"
end

def output_views_by_author(reviews_by_author, excluding_user)
  reviews_by_author.delete(excluding_user)
  if reviews_by_author.keys.size == 0
    puts "No reviews yet"
    return
  end

  reviews_by_author.each do | author, author_reviews|
    approved = author_reviews.any?{ |ar| ar["state"] == 'APPROVED' }
    output_approved_reviews(author, author_reviews) if approved
    output_unapproved_reviews(author, author_reviews) unless approved
  end
end

def extract_reviews_by_author(pr_num)
  response = JSON.parse(`gh pr view #{pr_num} --json reviews`.strip)
  reviews = response["reviews"]

  reviews_by_author={}
  reviews.each do | review |
    author = review["author"]["login"]
    reviews_by_author[author] ||= []
    reviews_by_author[author] << review
  end

  reviews_by_author
end

def extract_failed_checks(pr_num)
  checks = `gh pr checks #{pr_num}`.strip.split("\n")
  return [] if checks.size == 0
  failed_checks = []
  checks.each do | check |
    passed = check.include?("pass")
    next if IGNORABLE_PR_CHECKS.any?{|x|check.start_with? x }
    (failed_checks << check) unless passed
  end
  failed_checks
end

def output_failed_checks(failed_checks)
  if failed_checks.size > 0
    puts "Failed checks:"
    failed_checks.each do | fc |
      puts "\e[31m#{fc}\e[0m"
    end
  end
end
### ---- main loop

checked_dirs = []
begin
  Dir.chdir(BASE) do
    Dir.each_child("./") do | child |
      child = child.gsub(/[^a-zA-Z0-9_-]/, "")

      next if IGNORABLE_DIRS.include? child
      next if File.file? child

      begin
        Dir.chdir(child) do
          # returns 128 if the dir is not part of a git repo
          next unless system("git -C ./ rev-parse")


          checked_dirs << child
          response = `gh pr list -A #{GH_USERNAME} 2>/dev/null`.strip.split("\n")
          #STDERR.puts response.join("\n")
          next if response.size == 0

          puts "#{child} ----------------------------------"

          response.each do | pr_line |
            pr_num = pr_line.match(/^(\d+).*/)[1] rescue nil
            error_and_die("Unable to extract PR number from\n\t#{pr_line.inspect}") unless pr_num
            pr_title = pr_line.split("\t")[1]


            puts "#{pr_num}: #{pr_title}"
            pr_details = `gh pr view #{pr_num} --json url`.strip

            pr_url = JSON.parse(pr_details)["url"]
            puts pr_url

            output_failed_checks(extract_failed_checks(pr_num))

            reviews_by_author = extract_reviews_by_author(pr_num)

            output_views_by_author(reviews_by_author, GH_USERNAME)
          end
        end
      rescue NameError, Errno::ENOENT => e
        unless child.end_with? "DS_Store"
          STDERR.puts("problem looking up PR data: #{e.message}")
          # STDERR.puts("Unable to cd to '#{child}' from #{Dir.pwd}")
        end
      end
    end
  end
rescue NameError, Errno::ENOENT
  STDERR.puts("Error switching into directories.")
  STDERR.puts("Is your BASE variable correct? #{BASE}")
  exit 78 #EX_CONFIG
end

puts "\n\nDone.\nchecked dirs: #{checked_dirs.sort.join(", ")}"
